#!/system/bin/sh
. /data/local/tmp/balkava_hardware/iommu/iommu_lib.sh

BASM_FILE="$1"
TMPDIR="/data/local/tmp/balkava_a/cache/basm_$$"
mkdir -p "$TMPDIR"
STATE_ROOT=/data/local/tmp/balkava_a
# POSIX-compliant basmrun hardware API extension for Balkava OS
LOGFILE="/data/local/tmp/balkava_hardware/logs.txt"
mkdir -p "$(dirname "$LOGFILE")" 2>/dev/null || true
: > "$LOGFILE" 2>/dev/null || true

# Global "registers"
AL=0; BL=0; CL=0; DL=0; R0=0; R1=0

get_arg() {
    key=$1
    shift
    for arg in "$@"; do
        case "$arg" in
            "$key"=*)
                echo "${arg#*=}"
                return 0
                ;;
        esac
    done
    return 1
}

# portable random byte (0-255)
rand_byte() {
    # awk rand() -> 0..1, seed with time + pid
    awk 'BEGIN {srand(); printf("%d\n", int(rand()*256)); }'
}

# --- UARTPRINT: colored output via printf (portable) ---
UARTPRINT() {
    text=$1
    color=${2:-32}  # default green
    # expand "+ AL" and "+BL" simple tokens in text
    # replace occurrences of "+ AL" or "+AL" with AL value (basic)
    text="$(printf "%s" "$text" | sed -e "s/+ *AL/$AL/g" -e "s/+ *BL/$BL/g")"
    printf "\033[%sm%s\033[0m\n" "$color" "$text"
    printf "%s UART: %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$text" >> "$LOGFILE" 2>/dev/null
}
# create a per-run memory dir
MEMDIR="/data/local/tmp/balkava_a/cache/basm_mem_$$"
mkdir -p "$MEMDIR" || exit 1

# pointer counter (simple integer). Start at 1000 to avoid tiny numbers accidentally colliding
PTR_COUNTER=1000

# helper to get file path for a pointer id
memfile() {
    # $1 = ptr id
    printf '%s/%s.bin' "$MEMDIR" "$1"
}

# PRINT wrapper used by BASM scripts
PRINT() {
    text=$1
    color=${2:-32}
    UARTPRINT "$text" "$color"
}

# key=value parser helper (POSIX-safe)
kv() {
    key=$1
    args=$2
    # print the value for KEY in the args string or empty
    printf "%s" "$args" | awk -v K="$key" '{
        for (i=1;i<=NF;i++) {
            if ($i ~ ("^"K"=")) {
                sub("^"K"=", "", $i);
                print $i; exit
            }
        }
    }'
}

# log helper
klog() {
    printf "%s %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$*" >> "$LOGFILE" 2>/dev/null
}

PCI_SCAN() { klog "PCI_SCAN"; UARTPRINT "PCI: scanning devices..." 36; AL=1; }
PCI_READ() {
    args=$*
    dev=$(kv "DEV" "$args")
    reg=$(kv "REG" "$args")
    klog "PCI_READ DEV=$dev REG=$reg"
    AL=$(rand_byte)
    # show hex like before (printf %X not in POSIX? it is supported)
    printfval=$(printf "%X" "$AL" 2>/dev/null || printf "%X" "$AL")
    UARTPRINT "PCI_READ DEV=$dev REG=$reg -> 0x$printfval" 33
}
PCI_WRITE() {
    klog "PCI_WRITE $*"; UARTPRINT "PCI_WRITE OK" 32; AL=0
}

RTC_READ() { AL=$(date '+%S'); klog "RTC_READ -> $AL"; }
RTC_SET() { klog "RTC_SET $*"; UARTPRINT "RTC set: $*" 35; AL=0; }

GPIO_SET() { args=$*; pin=$(kv "PIN" "$args"); val=$(kv "VAL" "$args")
    klog "GPIO_SET PIN=$pin VAL=$val"; UARTPRINT "GPIO $pin -> $val" 33; AL=$val
}
GPIO_GET() { args=$*; pin=$(kv "PIN" "$args"); AL=$(awk 'BEGIN{srand(); print int(rand()*2)}'); klog "GPIO_GET PIN=$pin -> $AL"; }
GPIO_MODE() { klog "GPIO_MODE $*"; UARTPRINT "GPIO mode set" 36; AL=0; }

I2C_SCAN() { klog "I2C_SCAN $*"; AL=1; UARTPRINT "I2C: devices found" 33; }
I2C_READ() { args=$*; klog "I2C_READ $args"; AL=$(rand_byte); UARTPRINT "I2C_READ -> $AL" 32; }
I2C_WRITE() { klog "I2C_WRITE $*"; UARTPRINT "I2C_WRITE OK" 32; AL=0; }

SPI_XFER() { klog "SPI_XFER $*"; AL=0; UARTPRINT "SPI_XFER DONE" 32; }

ADC_READ() { args=$*; ch=$(kv "CH" "$args"); AL=$(awk 'BEGIN{srand(); print int(rand()*4096)}'); klog "ADC_READ CH=$ch -> $AL"; }
DAC_WRITE() { klog "DAC_WRITE $*"; AL=0; }

PWM_SET() { klog "PWM_SET $*"; UARTPRINT "PWM set" 36; AL=0; }

TEMP_READ() { args=$*; dev=$(kv "DEV" "$args"); AL=$(awk 'BEGIN{srand(); print int(30 + rand()*50)}'); klog "TEMP_READ DEV=$dev -> $AL"; }
FAN_SET() { args=$*; dev=$(kv "DEV" "$args"); speed=$(kv "SPEED" "$args"); klog "FAN_SET $dev SPEED=$speed"; AL=$speed; }
FAN_GET() { AL=$(awk 'BEGIN{srand(); print int(rand()*100)}'); klog "FAN_GET -> $AL"; }

FB_INIT() { klog "FB_INIT $*"; UARTPRINT "Framebuffer initted" 36; AL=0; }
FB_PUTPIXEL() { klog "FB_PUTPIXEL $*"; AL=0; }
FB_FILLRECT() { klog "FB_FILLRECT $*"; AL=0; }
FB_SWAPBUF() { klog "FB_SWAPBUF"; AL=0; }

AUDIO_INIT() { klog "AUDIO_INIT $*"; AL=0; }
AUDIO_PLAY() { file=$(kv "FILE" "$*"); klog "AUDIO_PLAY $file"; UARTPRINT "Playing $file" 35; AL=0; }
AUDIO_STOP() { klog "AUDIO_STOP"; AL=0; }

BAT_STATUS() { AL=1; klog "BAT_STATUS -> ok"; }
BAT_LEVEL() { AL=$(awk 'BEGIN{srand(); print int(rand()*100)}'); klog "BAT_LEVEL -> $AL"; }
BAT_CHARGE() { klog "BAT_CHARGE $*"; AL=0; }

# RNG: return hex string in AL
RNG_HW() {
    args=$*
    size=$(kv "SIZE" "$args")
    size=${size:-16}
    out=""
    i=1
    while [ "$i" -le "$size" ]; do
        b=$(rand_byte)
        # format to two hex digits
        hex=$(printf "%02X" "$b" 2>/dev/null || awk 'BEGIN{printf "%02X\n",'$b'}')
        out="${out}${hex}"
        i=$(expr "$i" + 1)
    done
    AL="$out"
    klog "RNG_HW SIZE=$size -> $AL"
}

KB_READ() { AL=$(rand_byte); klog "KB_READ -> $AL"; }
KB_LED() { klog "KB_LED $*"; AL=0; }

SETREG() { reg=$1; val=$2; # eval like "AL=5"
    case "$reg" in
        AL|BL|CL|DL|R0|R1) eval "$reg=$val"; klog "SETREG $reg=$val"; AL=0 ;;
        *) klog "SETREG unknown reg $reg"; AL=1 ;;
    esac
}
GETREG() { reg=$1; case "$reg" in AL|BL|CL|DL|R0|R1) eval "printf '%s\n' \$$reg";; *) printf '\n';; esac }

STARTDMA(){ klog "STARTDMA $*"; AL=1; }
STOPDMA(){ klog "STOPDMA"; AL=0; }

MOUSEEVENT(){ AL=$(awk 'BEGIN{srand(); print int(rand()*800)}'); BL=$(awk 'BEGIN{srand(); print int(rand()*600)}'); klog "MOUSEEVENT AL=$AL BL=$BL"; }
PLAYSOUND(){ klog "PLAYSOUND $*"; AL=0; }
SETTIMER(){ klog "SETTIMER $*"; AL=0; }
STOPTIMER(){ klog "STOPTIMER $*"; AL=0; }

SENDPACKET(){ klog "SENDPACKET $*"; AL=0; }
RECEIVEPACKET(){ AL="DATA$(awk 'BEGIN{srand(); print int(rand()*1000)}')"; klog "RECEIVEPACKET -> $AL"; }

KLOG_WRITE(){ msg=$(kv "MSG" "$*"); klog "KLOG_WRITE $msg"; AL=0; }
STATE_ROOT=${STATE_ROOT:-/tmp/balkava_core}
mkdir -p "$STATE_ROOT/boot/tlb" "$STATE_ROOT/boot/coherent" "$STATE_ROOT/boot/swap" "$STATE_ROOT/proc" "$STATE_ROOT/proc/" "$STATE_ROOT/sys/class/softirq" "$STATE_ROOT/tmp/dm" "$STATE_ROOT/tmp/overlay" "$STATE_ROOT/tmp/checkpoint" "$STATE_ROOT/tmp/oom" "$STATE_ROOT/tmp/cgroupv2" 2>/dev/null || true

# 1) Tiny TLB cache (map iova->phys cached)
tlb_put() {
  key="$1"; phys="$2"
  echo "$phys" > "$STATE_ROOT/boot/tlb/$key"
  printf "OK\n"
}
tlb_get() {
  key="$1"
  if [ -f "$STATE_ROOT/boot/tlb/$key" ]; then
    cat "$STATE_ROOT/boot/tlb/$key"
  else
    printf "MISS\n"
  fi
}
tlb_invalidate() {
  key="$1"; rm -f "$STATE_ROOT/boot/tlb/$key" 2>/dev/null || true; printf "OK\n"
}
tlb_flush() { rm -f "$STATE_ROOT/boot/tlb/"* 2>/dev/null || true; printf "OK\n" ;}

# 2) Coherent DMA pool (simulate CPU-cache-coherent DMA)
coherent_alloc() {
  id="$1"; size="$2"
  dd if=/dev/zero bs=1 count="$size" 2>/dev/null > "$STATE_ROOT/boot/coherent/$id"
  printf "OK\n"
}
coherent_free() { rm -f "$STATE_ROOT/boot/coherent/$1" 2>/dev/null || true; printf "OK\n"; }
coherent_sync_cpu_to_dev() { echo "SYNC CPU->DEV $1" ; }
coherent_sync_dev_to_cpu() { echo "SYNC DEV->CPU $1" ; }

# 3) Swap reclaimer sim (evict pages)
swap_reclaim() {
  pages="$1"
  # pretend to free pages by removing oldest page files
  cnt=0
  for f in "$STATE_ROOT/config/page/"*; do
    [ -f "$f" ] || continue
    rm -f "$f"
    cnt=`expr $cnt + 1`
    [ "$cnt" -ge "$pages" ] && break
  done
  printf "RECLAIMED %s\n" "$cnt"
}

# 4) /proc fakery: expose custom entries
proc_write() {
  path="$1"; data="$2"
  mkdir -p "$STATE_ROOT/proc/$(dirname "$path")" 2>/dev/null || true
  printf "%s\n" "$data" > "$STATE_ROOT/proc/$path"
  printf "OK\n"
}
proc_read() {
  path="$1"
  cat "$STATE_ROOT/proc/$path" 2>/dev/null || printf "(empty)\n"
}
proc_list() { find "$STATE_ROOT/proc" -type f 2>/dev/null | sed "s#^$STATE_ROOT/proc/##" || printf "(none)\n"; }

# 5) Syscall injector (danger: test-only)
syscall_inject() {
  pid="$1"; name="$2"; args="$3"
  # log as if a syscall happened
  echo "$(date '+%F %T') INJECT pid=$pid syscall=$name args=$args" >> "$STATE_ROOT/dev/kmsg"
  printf "OK\n"
}

# 6) Power governor model (tiny)
gov_set() { cpu="$1"; gov="$2"; echo "$gov" > "$STATE_ROOT/sys/class/cpu/gov/$cpu"; printf "OK\n"; }
gov_get() { cpu="$1"; cat "$STATE_ROOT/sys/class/cpu/gov/$cpu" 2>/dev/null || printf "ondemand\n"; }

# 7) Userspace loader stub (validate ELF-like, fake mapping & start)
userspace_load() {
  pid="$1"; file="$2"
  if [ ! -f "$file" ]; then printf "ERR:NOFILE\n"; return 1; fi
  mkdir -p "$STATE_ROOT/proc/$pid"
  echo "$file" > "$STATE_ROOT/proc/$pid/exe"
  echo "LOADED" > "$STATE_ROOT/proc/$pid/state"
  printf "OK\n"
}
userspace_run() {
  pid="$1"
  if [ -f "$STATE_ROOT/proc/$pid/exe" ]; then
    printf "RUNNING %s\n" "$(cat "$STATE_ROOT/proc/$pid/exe")"
  else
    printf "ERR:NOPROC\n"
  fi
}

# 8) Scheduler load balancer (move PID -> CPU)
sched_balance_move() {
  pid="$1"; cpu="$2"
  mkdir -p "$STATE_ROOT/sys/kernel/debug/sched/assignment"
  echo "$cpu" > "$STATE_ROOT/sys/kernel/debug/sched/assignment/$pid"
  printf "OK\n"
}
sched_balance_show() {
  for f in "$STATE_ROOT/sys/kernel/debug/sched/assignment/"*; do [ -f "$f" ] || continue; printf "%s -> %s\n" "$(basename "$f")" "$(cat "$f")"; done
}

# 9) cgroupv2 basic (create/remove/limit/list)
cgroupv2_create() { name="$1"; mkdir -p "$STATE_ROOT/sys/class/cgroupv2/$name"; printf "OK\n"; }
cgroupv2_set_limit() { name="$1"; mem="$2"; echo "$mem" > "$STATE_ROOT/sys/class/cgroupv2/$name/memory.max"; printf "OK\n"; }
cgroupv2_list() { for d in "$STATE_ROOT/sys/class/cgroupv2/"*; do [ -d "$d" ] && printf "%s\n" "$(basename "$d")"; done; }

# 10) OOM killer stub (choose victim by heuristic)
oom_kill() {
  # pick random process file under ps/
  victim=""
  for f in "$STATE_ROOT/proc/"*; do [ -d "$f" ] || continue; victim="$(basename "$f")"; break; done
  if [ -z "$victim" ]; then printf "NOPROC\n"; else rm -rf "$STATE_ROOT/proc/$victim"; printf "KILLED %s\n" "$victim"; fi
}

# 11) Demand paging / pager (simulate page fault & load on access)
pager_set_backing() {
  pid="$1"; pageid="$2"; file="$3"
  mkdir -p "$STATE_ROOT/proc/$pid"
  echo "$file" > "$STATE_ROOT/proc/$pid/$pageid"
  printf "OK\n"
}
pager_handle_fault() {
  pid="$1"; pageid="$2"
  if [ -f "$STATE_ROOT/proc/$pid/$pageid" ]; then
    file=$(cat "$STATE_ROOT/proc/$pid/$pageid")
    printf "PAGE_LOADED %s FOR %s\n" "$file" "$pid"
  else
    printf "PAGE_NOT_FOUND\n"
  fi
}

# 12) Softirq / softnet toy (schedule bottom-half handler labels)
softirq_raise() {
  id="$1"; echo "$id" >> "$STATE_ROOT/sys/class/softirq/queue"; printf "OK\n"
}
softirq_run() {
  while IFS= read -r h; do [ -n "$h" ] || continue; printf "HANDLER:%s\n" "$h"; done < "$STATE_ROOT/sys/class/softirq/queue" 2>/dev/null || true
  > "$STATE_ROOT/sys/class/softirq/queue" 2>/dev/null || true
}

# 13) Device Mapper-ish table (create map and snapshot)
dm_table_add() {
  name="$1"; devs="$2"; echo "$devs" > "$STATE_ROOT/tmp/dm/$name"; printf "OK\n"
}
dm_table_get() { name="$1"; cat "$STATE_ROOT/tmp/dm/$name" 2>/dev/null || printf "NOTFOUND\n"; }
dm_snapshot() { name="$1"; snap="$2"; cp -a "$STATE_ROOT/tmp/dm/$name" "$STATE_ROOT/tmp/dm/$snap" 2>/dev/null || true; printf "SNAPOK\n"; }

# 14) Overlayfs mock (upper/lower)
overlay_mount() {
  name="$1"; lower="$2"; upper="$3"
  mkdir -p "$STATE_ROOT/tmp/overlay/$name"
  echo "LOWER=$lower" > "$STATE_ROOT/tmp/overlay/$name/info"
  echo "UPPER=$upper" >> "$STATE_ROOT/tmp/overlay/$name/info"
  printf "OK\n"
}
overlay_ls() { name="$1"; cat "$STATE_ROOT/tmp/overlay/$name/info" 2>/dev/null || printf "NONE\n"; }

# 15) Checkpoint / restore (serialize process directory)
checkpoint_create() { pid="$1"; ck="$2"; tar -cf "$STATE_ROOT/tmp/checkpoint/$ck.tar" -C "$STATE_ROOT/ps" "$pid" 2>/dev/null || true; printf "OK\n"; }
checkpoint_restore() { ck="$1"; tar -xf "$STATE_ROOT/tmp/checkpoint/$ck.tar" -C "$STATE_ROOT/tmp/poop" 2>/dev/null || true; printf "OK\n"; }

# 16) Admin: list modules & symbol stub
mod_list() { ls "$STATE_ROOT/sys/module" 2>/dev/null || printf "(none)\n"; }
mod_symbols() { mod="$1"; printf "sym_foo 0xdeadbeef\n"; }

# 17) Sysadmin tiny tools (parse boot args)
bootparam_set() { key="$1"; val="$2"; echo "$val" > "$STATE_ROOT/boot/$key"; printf "OK\n"; }
bootparam_get() { key="$1"; cat "$STATE_ROOT/boot/$key" 2>/dev/null || printf "(unset)\n"; }

mkdir -p "$STATE_ROOT/dma" "$STATE_ROOT/numa" "$STATE_ROOT/cgroup" "$STATE_ROOT/klog" "$STATE_ROOT/page" "$STATE_ROOT/timer" 2>/dev/null || true
# ---- MASSIVE EXTRA KERNEL API PACK (POSIX) ----
mkdir -p "${STATE_ROOT:-/tmp/balkava_core}/sys/perf" "${STATE_ROOT:-/tmp/balkava_core},/sys/class/watchdog" 2>/dev/null || true 

# 1) Perf counters (start/stop/read)
perf_start() {
  name=$1
  echo "$(date +%s)" > "${STATE_ROOT:-/tmp/balkava_core}/sys/perf/$name.start" 2>/dev/null || true
  printf "OK\n"
}

perf_stop() {
  name=$1
  startf="${STATE_ROOT:-/tmp/balkava_core}/sys/perf/$name.start"
  [ -f "$startf" ] || { printf "ERR\n"; return 1; }
  start=$(cat "$startf")
  dur=$(( $(date +%s) - start ))
  echo "$dur" > "${STATE_ROOT:-/tmp/balkava_core}/sys/perf/$name" 2>/dev/null || true
  rm -f "$startf" 2>/dev/null || true
  printf "OK\n"
}
perf_read() {
  name=$1
  cat "${STATE_ROOT:-/tmp/balkava_core}/sys/perf/$name" 2>/dev/null || printf "0\n"
}

# 2) Watchdog (set/kick/status)
watchdog_set() {
  id=$1; ms=$2
  echo "$ms" > "${STATE_ROOT:-/tmp/balkava_core}/sys/class/watchdog/$id"
  printf "OK\n"
}
watchdog_kick() {
  id=$1
  if [ -f "${STATE_ROOT:-/tmp/balkava_core}/sys/class/watchdog/$id" ]; then
    echo "$(date +%s)" > "${STATE_ROOT:-/tmp/balkava_core}/watchdog/$id.last"
    printf "KICKED\n"
  else
    printf "NOTSET\n"
  fi
}
watchdog_status() {
  id=$1
  ls -l "${STATE_ROOT:-/tmp/balkava_core}/sys/class/watchdog/$id" 2>/dev/null || printf "NONE\n"
}

# 3) Firmware loader stub (load/unload/list)
fw_load() {
  dev=$1; file=$2
  mkdir -p "${STATE_ROOT:-/tmp/balkava_core}/firmware" 2>/dev/null || true
  echo "$file" > "${STATE_ROOT:-/tmp/balkava_core}/firmware/$dev"
  printf "OK\n"
}
fw_unload() {
  dev=$1
  rm -f "${STATE_ROOT:-/tmp/balkava_core}/firmware/$dev" 2>/dev/null || true
  printf "OK\n"
}
fw_list() {
  for f in "${STATE_ROOT:-/tmp/balkava_core}/firmware/"*; do [ -f "$f" ] && printf "%s: %s\n" "$(basename "$f")" "$(cat "$f")"; done 2>/dev/null
}

# 4) CPUfreq mock (set/get governor & frequency)
cpufreq_set() { cpu=$1; gov=$2; freq=$3; mkdir -p "${STATE_ROOT:-/tmp/balkava_core}/sys/cpufreq"; echo "$gov,$freq" > "${STATE_ROOT:-/tmp/balkava_core}/sys/cpufreq/$cpu"; printf "OK\n"; }
cpufreq_get() { cpu=$1; cat "${STATE_ROOT:-/tmp/balkava_core}/sys/class/cpu/cpufreq/$cpu" 2>/dev/null || printf "ondemand,0\n"; }

# 5) Entropy pool (seed/read)
entropy_seed() { printf "%s\n" "$2" >> "${STATE_ROOT:-/tmp/balkava_core}/boot/entropy/seed"; printf "OK\n"; }
entropy_read() { head -c "${1:-16}" /dev/urandom | xxd -p -c "${1:-16}"; }

# 6) Swap simulate (set swappiness / show)
swap_set_swappiness() { v=$1; echo "$v" > "${STATE_ROOT:-/tmp/balkava_core}/boot/swap/swappiness"; printf "OK\n"; }
swap_show() { cat "${STATE_ROOT:-/tmp/balkava_core}/boot/swap/swappiness" 2>/dev/null || printf "60\n"; }

# 7) Seccomp-like small filter (allow/deny by syscall name)
seccomp_allow() { echo "ALLOW $1" >> "${STATE_ROOT:-/tmp/balkava_core}/boot/seccomp.rules"; printf "OK\n"; }
seccomp_deny() { echo "DENY $1" >> "${STATE_ROOT:-/tmp/balkava_core}/boot/seccomp.rules"; printf "OK\n"; }
seccomp_list() { cat "${STATE_ROOT:-/tmp/balkava_core}/seccomp.rules" 2>/dev/null || printf "(none)\n"; }

# 8) Audit event (log + query)
audit_log() { who=$1; what=$2; echo "$(date '+%F %T') $who $what" >> "${STATE_ROOT:-/tmp/balkava_core}/boot/audit.log"; printf "OK\n"; }
audit_query() { grep "$1" "${STATE_ROOT:-/tmp/balkava_core}/audit.log" 2>/dev/null || printf "(no events)\n"; }

# 9) Hotplug device attach/detach (and list)
hotplug_attach() { dev=$1; echo "$(date +%s)" > "${STATE_ROOT:-/tmp/balkava_core}/dev/$dev"; printf "ATTACHED\n"; }
hotplug_detach() { dev=$1; rm -f "${STATE_ROOT:-/tmp/balkava_core}/sys/class/hotplug/$dev" 2>/dev/null || true; printf "DETACHED\n"; }
hotplug_list() { for f in "${STATE_ROOT:-/tmp/balkava_core}/hotplug/"*; do [ -f "$f" ] && printf "%s\n" "$(basename "$f")"; done 2>/dev/null; }

# 10) Kernel module param setter (fake /sys/module/..)
modparam_set() { mod=$1; param=$2; val=$3; mkdir -p "${STATE_ROOT:-/tmp/balkava_core}/sys/module/$mod/"; echo "$val" > "${STATE_ROOT:-/tmp/balkava_core}/sys/module/$mod/$param"; printf "OK\n"; }
modparam_get() { mod=$1; param=$2; cat "${STATE_ROOT:-/tmp/balkava_core}/sys/module/$mod/$param" 2>/dev/null || printf "undef\n"; }

# 11) Namespace mock (create/list/enter)
ns_create() { name=$1; mkdir -p "${STATE_ROOT:-/tmp/balkava_core}/ns/$name"; printf "OK\n"; }
ns_list() { for n in "${STATE_ROOT:-/tmp/balkava_core}/ns/"*; do [ -d "$n" ] && printf "%s\n" "$(basename "$n")"; done 2>/dev/null; }
ns_enter() { name=$1; [ -d "${STATE_ROOT:-/tmp/balkava_core}/ns/$name" ] && printf "ENTERED %s\n" "$name" || printf "NO_NS\n"; }

# 12) eBPF stub register/unregister/run (fake)
ebpf_load() { id=$1; echo "$2" > "${STATE_ROOT:-/tmp/balkava_core}/sys/ebpf/$id" 2>/dev/null || true; printf "OK\n"; }
ebpf_unload() { id=$1; rm -f "${STATE_ROOT:-/tmp/balkava_core}/ebpf/$id" 2>/dev/null || true; printf "OK\n"; }
ebpf_run() { id=$1; echo "RUN:$id" >> "${STATE_ROOT:-/tmp/balkava_core}/dev/kmsg"; printf "OK\n"; }

# 13) Kernel panic simulation (dump state)
panic_dump() {
  echo "PANIC DUMP: $(date '+%F %T')" > "${STATE_ROOT:-/tmp/balkava_core}/misc/dump"
  echo "perf:"; ls "${STATE_ROOT:-/tmp/balkava_core}/perf" 2>/dev/null || true
  printf "DUMPED\n"
}

# 14) Throttle/mock CPU offline (take cpu offline)
cpu_offline() { id=$1; echo "offline" > "${STATE_ROOT:-/tmp/balkava_core}/sys/cpu/$id"; printf "OK\n"; }
cpu_online()  { id=$1; echo "online" > "${STATE_ROOT:-/tmp/balkava_core}/sys/cpu/$id"; printf "OK\n"; }
cpu_status()  { id=$1; cat "${STATE_ROOT:-/tmp/balkava_core}/sys/cpu/$id" 2>/dev/null || printf "online\n"; }

# 15) Kernel ring buffer reader (circular tail)
ring_write() { echo "$(date '+%H:%M:%S') $*" >> "${STATE_ROOT:-/tmp/balkava_core}/config/ring"; tail -n 200 "${STATE_ROOT:-/tmp/balkava_core}/ring" > "${STATE_ROOT:-/tmp/balkava_core}/ring.tmp" 2>/dev/null || true; mv "${STATE_ROOT:-/tmp/balkava_core}/ring.tmp" "${STATE_ROOT:-/tmp/balkava_core}/ring" 2>/dev/null || true; }
ring_read() { tail -n "${1:-50}" "${STATE_ROOT:-/tmp/balkava_core}/ring" 2>/dev/null || printf "(empty)\n"; }

# -- DMA buffer pool --
dma_alloc() {
  id=$1; size=$2
  dd if=/dev/zero bs=1 count="$size" 2>/dev/null > "$STATE_ROOT/sys/class/dma/$id"
  printf "DMA buffer %s allocated (%s bytes)\n" "$id" "$size"
}
dma_free() {
  rm -f "$STATE_ROOT/dma/$1" 2>/dev/null || true
  printf "DMA buffer %s freed\n" "$1"
}

# -- NUMA node sim --
numa_add_node() {
  id=$1; cpus=$2
  echo "$cpus" > "$STATE_ROOT/sys/class/numa/$id"
  printf "NUMA node %s with CPUs %s added\n" "$id" "$cpus"
}
numa_list_nodes() {
  for n in "$STATE_ROOT/sys/class/numa/"*; do
    [ -f "$n" ] && printf "Node %s: CPUs %s\n" "$(basename "$n")" "$(cat "$n")"
  done
}

# -- Cgroups mock --
cgroup_create() {
  name=$1
  mkdir -p "$STATE_ROOT/sys/cgroup/$name"
  printf "Cgroup %s created\n" "$name"
}
cgroup_add_task() {
  name=$1; pid=$2
  echo "$pid" >> "$STATE_ROOT/sys/cgroup/$name/tasks"
  printf "PID %s added to cgroup %s\n" "$pid" "$name"
}
cgroup_list() {
  for cg in "$STATE_ROOT/sys/cgroup/"*; do
    [ -d "$cg" ] && {
      printf "Cgroup %s: " "$(basename "$cg")"
      cat "$cg/tasks" 2>/dev/null || printf "(empty)\n"
    }
  done
}

# -- Kernel log ringbuffer --
klog_read() {
  cat "$STATE_ROOT/dev/kmsg" 2>/dev/null || printf "(no logs)\n"
}

# -- Page allocator mock --
page_alloc() {
  id=$1; count=$2
  dd if=/dev/zero bs=4096 count="$count" 2>/dev/null > "$STATE_ROOT/sys/class/page/$id"
  printf "Allocated %s pages for %s\n" "$count" "$id"
}
page_free() {
  rm -f "$STATE_ROOT/sys/class/page/$1" 2>/dev/null || true
  printf "Freed pages for %s\n" "$1"
}

# -- Timer subsystem --
timer_set() {
  id=$1; ms=$2
  echo "$ms" > "$STATE_ROOT/config/timer/$id"
  printf "Timer %s set to %sms\n" "$id" "$ms"
}
timer_get() {
  id=$1
  [ -f "$STATE_ROOT/config/timer/$id" ] && cat "$STATE_ROOT/config/timer/$id" || printf "NOTSET\n"
}
mkdir -p "$STATE_ROOT/.tmp/mutex" "$STATE_ROOT/irq" "$STATE_ROOT/cache" "$STATE_ROOT/sysinfo" "$STATE_ROOT/traps" "$STATE_ROOT/sched" 2>/dev/null || true

# -- Mutex lock/unlock --
mutex_lock() {
  name=$1
  lockf="$STATE_ROOT/mutex/$name.lock"
  if [ -f "$lockf" ]; then
    printf "BUSY\n"; return 1
  fi
  echo $$ > "$lockf"
  printf "LOCKED\n"
}
mutex_unlock() {
  name=$1
  rm -f "$STATE_ROOT/.tmp/mutex/$name.lock" 2>/dev/null || true
  printf "UNLOCKED\n"
}

# -- IRQ (simulate interrupt registration/trigger) --
irq_register() {
  num=$1; handler=$2
  echo "$handler" > "$STATE_ROOT/sys/class/irq/$num"
  printf "OK\n"
}
irq_trigger() {
  num=$1
  [ -f "$STATE_ROOT/irq/$num" ] && cat "$STATE_ROOT/irq/$num" || printf "NOHANDLER\n"
}

# -- CPU cache control (fake flush/invalidate) --
cache_flush() {
  level=$1
  printf "CACHE L%s FLUSHED\n" "$level"
}
cache_invalidate() {
  level=$1
  printf "CACHE L%s INVALIDATED\n" "$level"
}

# -- System info dump --
sysinfo_dump() {
  buname -r
  printf "STATE_ROOT=%s\n" "$STATE_ROOT"
  printf "PID=%s\n" "$$"
}

# -- Trap table (register and show) --
trap_set() {
  id=$1; action=$2
  echo "$action" > "$STATE_ROOT/.tmp/traps/$id"
  printf "OK\n"
}
trap_show() {
  id=$1
  [ -f "$STATE_ROOT/.tmp/traps/$id" ] && cat "$STATE_ROOT/traps/$id" || printf "NONE\n"
}

# -- Scheduler tweak (set quantum per task) --
sched_set_quantum() {
  pid=$1; ms=$2
  echo "$ms" > "$STATE_ROOT/sys/kernel/sched/$pid"
  printf "OK\n"
}
sched_get_quantum() {
  pid=$1
  [ -f "$STATE_ROOT/sys/kernel/sched/$pid" ] && cat "$STATE_ROOT/sys/kernel/sched/$pid" || printf "DEFAULT\n"
}
# --- hardware functions ---
keyboard_interrupt() {
    local key=$((RANDOM % 256))
    echo "Keyboard interrupt: key=$key" >> /data/local/tmp/balkava_hardware/logs.txt
    AL=$key
}
# ---- EXTRA KERNEL APIs (POSIX) ----
mkdir -p "$STATE_ROOT/timers" "$STATE_ROOT/sys/class/ipc" "$STATE_ROOT/power" "$STATE_ROOT/fault" 2>/dev/null || true

# -- Timer API (create/cancel) --
# TIMER_CREATE ID=<id> MS=<millis> CALLBACK=<label>
timer_create() {
  id=$1; ms=$2; cb=$3
  printf "%s\n" "$ms:$cb" > "$STATE_ROOT/config/timers/$id" 2>/dev/null || true
  printf "OK\n"
}
timer_cancel() {
  id=$1
  rm -f "$STATE_ROOT/config/timers/$id" 2>/dev/null || { printf "ERR\n"; return 1; }
  printf "OK\n"
}
timer_list() {
  for f in "$STATE_ROOT"/config/timers/*; do [ -f "$f" ] || continue; basename "$f"; done 2>/dev/null
}

# -- IPC (very small message queue) --
# IPC_SEND Q=<id> FROM=<who> MSG="text"
# IPC_RECV Q=<id>
ipc_send() {
  q=$1; from=$2; msg=$3
  mkdir -p "$STATE_ROOT/sys/class/ipc/$q" 2>/dev/null || true
  printf "%s|%s\n" "$from" "$msg" >> "$STATE_ROOT/sys/class/ipc/$q/msgs"
  printf "OK\n"
}
ipc_recv() {
  q=$1
  f="$STATE_ROOT/sys/class/ipc/$q/msgs"
  if [ -f "$f" ]; then
    sed -n '1p' "$f"
    # drop the first line (consume)
    tail -n +2 "$f" > "$f.tmp" 2>/dev/null || true
    mv "$f.tmp" "$f" 2>/dev/null || true
  else
    printf "\n"
  fi
}

# -- Device power (suspend/resume state) --
# DEV_POWER DEV=<name> ACTION=<suspend|resume|state>
dev_power() {
  dev=$1; act=$2
  mkdir -p "$STATE_ROOT/sys/power" 2>/dev/null || true
  case "$act" in
    suspend) echo "suspended" > "$STATE_ROOT/sys/power/$dev"; printf "OK\n" ;;
    resume) echo "on" > "$STATE_ROOT/sys/power/$dev"; printf "OK\n" ;;
    state) [ -f "$STATE_ROOTl/sys/power/$dev" ] && cat "$STATE_ROOT/sys/power/$dev" || echo "unknown";;
    *) printf "ERR\n"; return 1 ;;
  esac
}

# -- Page-table map with alignment check (PT_MAP) --
# PT_MAP PID=<pid> VADDR=0x... PADDR=0x... SIZE=<bytes> (enforces 4096 alignment)
pt_map_safe() {
  pid=$1; vaddr=$2; paddr=$3; size=$4
  # check alignment (4096)
  vdec=$(printf "%d" "$vaddr" 2>/dev/null || printf "%d" "0")
  pdec=$(printf "%d" "$paddr" 2>/dev/null || printf "%d" "0")
  modv=`expr $vdec % 4096`
  modp=`expr $pdec % 4096`
  if [ "$modv" -ne 0 ] || [ "$modp" -ne 0 ]; then
    printf "ERR:ALIGN\n"; return 1
  fi
  mkdir -p "$STATE_ROOT/proc/$pid" 2>/dev/null || true
  printf "%s,%s,%s\n" "$vaddr" "$paddr" "$size" >> "$STATE_ROOT/proc/$pid/maps"
  printf "OK\n"
}

# -- Random fault injector (for testing resilience) --
# FAULT_INJECT TARGET=<subsystem> TYPE=<panic|delay|drop> PROB=<0-100>
fault_inject() {
  target=$1; typ=$2; prob=$3
  mkdir -p "$STATE_ROOT/.tmp/fault" 2>/dev/null || true
  printf "%s|%s|%s\n" "$target" "$typ" "$prob" > "$STATE_ROOT/fault/$target"
  printf "OK\n"
}
fault_status() {
  target=$1
  [ -f "$STATE_ROOT/.tmp/fault/$target" ] && cat "$STATE_ROOT/fault/$target" || printf "none\n"
}

timer_interrupt() {
    local tick=$((RANDOM % 1000))
    echo "Timer tick: $tick" >> /data/local/tmp/balkava_hardware/logs.txt
    AL=$tick
}

disk_error_check() {
    local sector="$1"
    local fail=$((RANDOM % 10))
    if [ $fail -eq 0 ]; then
        echo "Disk error on sector $sector!" >> /data/local/tmp/balkava_hardware/logs.txt
    else
        echo "Disk sector $sector OK" >> /data/local/tmp/balkava_hardware/logs.txt
    fi
}

random_hardware_event() {
    local event=$((RANDOM % 3))
    case $event in
        0) keyboard_interrupt ;;
        1) timer_interrupt ;;
        2) disk_error_check $((RANDOM % 10)) ;;
    esac
}
# --- PRINT function for fucntions ---
PRINT() {
    local text="$1"
    local color="${2:-32}"   # default green
    echo "$text" "$color"
}

# --- Hardware simulation functions for basmrun ---
readport() {
    local port="$1"
    # simulate reading from hardware port
    # just return a fake value
    echo "AB"   # always return 0xAB for testing
}

writeport() {
    local port="$1"
    local value="$2"
    # simulate writing to hardware port
    echo "Wrote $value to PORT $port" >> /data/local/tmp/balkava_hardware/logs.txt
}

pollstatus() {
    local port="$1"
    local status=0
    while [ $status -lt 5 ]; do
        status=$((status + 1))
        sleep 0.01
    done

# Memory access (fake)
READMEM() {
    local addr="$1"
    val=$((RANDOM % 256))
    echo "$val"
}

# Fake CPU flags
SETFLAG() {
    local flag="$1"
    echo "Flag $flag SET" >> /data/local/tmp/balkava_hardware/logs.txt
}

CLEARFLAG() {
    local flag="$1"
    echo "Flag $flag CLEARED" >> /data/local/tmp/balkava_hardware/logs.txt
}

# Simulate interrupts queue
TRIGGERINT() {
    local intnum="$1"
    echo "Interrupt $intnum triggered" >> /data/local/tmp/balkava_hardware/logs.txt
    AL=$((RANDOM % 256))   # store random value in AL
}

# Hardware timer + RTC
READRTC() {
    val=$(date +%S)
    echo "$val"
}

WRITERTC() {
    local val="$1"
    echo "RTC set to $val" >> /data/local/tmp/balkava_hardware/logs.txt
}

# GPU / Display simulation
WRITEVIDEO() {
    local addr="$1"
    local val="$2"
    echo "Wrote $val to video memory $addr" >> /data/local/tmp/balkava_hardware/logs.txt
}

READVIDEO() {
    local addr="$1"
    val=$((RANDOM % 256))
    echo "$val"
}

# --- DMA simulation ---
STARTDMA() {
    local src="$1"
    local dst="$2"
    local size="$3"
    echo "DMA started from $src -> $dst, size=$size" >> /data/local/tmp/balkava_hardware/logs.txt
}

# ---- Kernel function: VFS Mount ----
vfs_mount() {
    local src="$1" type="$2" mnt="$3"
    mkdir -p "/data/local/tmp/balkava_a/tmp/balkava_vfs$mnt"
    echo "Mounted $src of type $type to $mnt"
}

# ---- Kernel function: Scheduler Create ----
sched_create() {
    local pid="$1" name="$2" pri="$3"
    echo "$pid,$name,$pri" >> /data/local/tmp/balkava_sched_table
    echo "Process $name (PID $pid) created with priority $pri"
}

STOPDMA() {
    echo "DMA stopped" >> /data/local/tmp/balkava_hardware/logs.txt
}

# --- Keyboard / Mouse ---
MOUSEEVENT() {
    local x=$((RANDOM % 800))
    local y=$((RANDOM % 600))
    echo "Mouse event at $x,$y" >> /data/local/tmp/balkava_hardware/logs.txt
    AL=$x
    BL=$y
}

# --- Sound / Speaker ---
PLAYSOUND() {
    local freq="$1"
    local dur="$2"
    echo "Playing sound freq=$freq Hz, duration=${dur}ms" >> /data/local/tmp/balkava_hardware/logs.txt
}

# --- Advanced Timer ---
SETTIMER() {
    local timer="$1"
    local interval="$2"
    echo "Timer $timer set to interval $interval ms" >> /data/local/tmp/balkava_hardware/logs.txt
}

STOPTIMER() {
    local timer="$1"
    echo "Timer $timer stopped" >> /data/local/tmp/balkava_hardware/logs.txt
}

# --- Network simulation ---
SENDPACKET() {
    local ip="$1"
    local port="$2"
    local data="$3"
    echo "Sent packet to $ip:$port, data=$data" >> /data/local/tmp/balkava_hardware/logs.txt
}

RECEIVEPACKET() {
    local ip="$1"
    local port="$2"
    val="DATA$((RANDOM % 1000))"
    echo "Received packet from $ip:$port -> $val" >> /data/local/tmp/balkava_hardware/logs.txt
    AL="$val"
}
# ---- helpers -----------------------------
num_to_fg() {
  case "$1" in
    0) printf '37' ;;  # white
    1) printf '31' ;;  # red
    2) printf '32' ;;  # green
    3) printf '34' ;;  # blue
    4) printf '90' ;;  # gray
    5) printf '33' ;;  # yellow
    6) printf '35' ;;  # violet
    *) printf '37' ;;
  esac
}

num_to_bg() {
  case "$1" in
    0) printf '47' ;;
    1) printf '41' ;;
    2) printf '42' ;;
    3) printf '44' ;;
    4) printf '100' ;;
    5) printf '43' ;;
    6) printf '45' ;;
    *) printf '40' ;;   # sane default background
  esac
}

# Safe extractors
extract_quoted_text() {  # gets first "..." chunk
  printf '%s\n' "$1" | sed -n 's/.*"\(.*\)".*/\1/p'
}

extract_count() {        # gets ;N (N digits), whitespace tolerated
  printf '%s\n' "$1" | sed -n 's/.*;[[:space:]]*\([0-9][0-9]*\).*/\1/p'
}

# Extract fg and bg numbers (supports "#2  #1" or "2 1")
extract_fg() {
  # only look before the first quote so spaces in the string don't ruin it
  printf '%s\n' "$1" | sed -n 's/^MULTIUARTPRINT[[:space:]]*#\{0,1\}\([0-6]\)[[:space:]]*#\{0,1\}\([0-6]\).*/\1/p'
}
extract_bg() {
  printf '%s\n' "$1" | sed -n 's/^MULTIUARTPRINT[[:space:]]*#\{0,1\}\([0-6]\)[[:space:]]*#\{0,1\}\([0-6]\).*/\2/p'
}
do_nothing() {
# do nothing just a stub function for my functions that do nothing
}
# -------------------------------------------------------------------

# init regs
for i in 0 1 2 3 4 5 6 7; do eval "reg$i=0"; done
sp=0
stack_file="$TMPDIR/stack"
touch "$stack_file"
last_cmp=1

# load lines
i=0
while IFS= read -r line; do
    echo "$line" > "$TMPDIR/line_$i"
    i=$((i+1))
done < "$BASM_FILE"
total=$i

# record labels
i=0
while [ $i -lt $total ]; do
    line=$(cat "$TMPDIR/line_$i")
    case "$line" in
        *:)
            label=$(echo "$line" | sed 's/:.*//')
            eval "label_$label=$i"
            ;;
    esac
    i=$((i+1))
done

# run
pc=0
running=1

while [ $running -eq 1 ]; do
    [ $pc -ge $total ] && break
    line=$(cat "$TMPDIR/line_$pc" | sed 's/;.*//;s/^ *//;s/ *$//')
    pc=$((pc+1))
    [ -z "$line" ] && continue

    set -- $line
    instr=$1

    # helpers
    getval() {
        if echo "$1" | grep -q '^#'; then echo $(( ${1#\#} ))
        else idx=${1#r}; eval echo "\$reg$idx"; fi
    }

    # Debug flag
DEBUG_BASMRUN=1  # set to 0 to disable debug

# Debug echo helper
dbg() {
if [ "$DEBUG_BASMRUN" -eq 1 ]; then
echo "[DEBUG] $*"
else
do_nothing
fi
}

# Set a register value with debug & pointer/array support

# POSIX-safe debug setreg
setreg() {
    orig="$1"
    val="$2"

    # Debug info
    dbg "DEBUG: setreg called with orig='$orig' val='$val'"

    # Check for struct access like abc->slot
    case "$orig" in
        *"->"*)
            struct=$(echo "$orig" | cut -d'>' -f1)
            field=$(echo "$orig" | cut -d'>' -f2 | cut -c2-)  # remove leading -
            dbg "DEBUG: Detected struct access: struct='$struct' field='$field'"
            eval "${struct}_${field}=\$val"
            ;;
        *"["*"]"*)
            # Array access r0[5] -> reg0 index 5
            reg=$(echo "$orig" | cut -d'[' -f1)
            idx=$(echo "$orig" | cut -d'[' -f2 | cut -d']' -f1)
            dbg "DEBUG: Detected array access: reg='$reg' idx='$idx'"
            eval "${reg}_${idx}=\$val"
            ;;
        r*)
            # normal register like r0
            idx=${orig#r}
            dbg "DEBUG: Detected register access: r$idx"
            eval "reg$idx=\$val"
            ;;
        *)
            dbg "DEBUG: Unknown setreg target: $orig"
            ;;
    esac
}

# POSIX-safe debug getreg
getreg() {
    orig="$1"
    val=""

    # Debug info
    echo "DEBUG: getreg called with orig='$orig'"

    case "$orig" in
        *"->"*)
            struct=$(echo "$orig" | cut -d'>' -f1)
            field=$(echo "$orig" | cut -d'>' -f2 | cut -c2-)  # remove leading -
            dbg "DEBUG: Detected struct access: struct='$struct' field='$field'"
            eval "val=\${${struct}_${field}:-0}"
            ;;
        *"["*"]"*)
            reg=$(echo "$orig" | cut -d'[' -f1)
            idx=$(echo "$orig" | cut -d'[' -f2 | cut -d']' -f1)
            dbg "DEBUG: Detected array access: reg='$reg' idx='$idx'"
            eval "val=\${${reg}_${idx}:-0}"
            ;;
        r*)
            idx=${orig#r}
            dbg "DEBUG: Detected register access: r$idx"
            eval "val=\${reg$idx:-0}"
            ;;
        *)
            dbg "DEBUG: Unknown getreg target: $orig"
            val=0
            ;;
    esac

    echo "$val"
}
gpio_toggle() { PIN="$1"; echo "[HW] GPIO pin $PIN toggled"; }
gpio_read() { PIN="$1"; echo "[HW] GPIO pin $PIN value simulated: $((RANDOM%2))"; }
gpio_write() { PIN="$1"; VAL="$2"; echo "[HW] GPIO pin $PIN set to $VAL"; }
cpu_sleep() { CPU="$1"; echo "[HW] CPU $CPU is now sleeping (simulated)"; }
cpu_wake() { CPU="$1"; echo "[HW] CPU $CPU woke up (simulated)"; }
cpu_perf_mode() { CPU="$1"; MODE="$2"; echo "[HW] CPU $CPU set to performance mode: $MODE"; }
cpu_idle() { CPU="$1"; echo "[HW] CPU $CPU is idle (simulated)"; }

log_msg_ret() {
    echo "E: $1 -> $2"
    return $2
}

log_debug() { # for find_in_blk function(for my bootloaders)
    echo "D: $*"
}


    case "$instr" in      # THIS CASE IS HOLDS ALL FUNCTIONS ON BASM  
SYSCALL|syscall)
ARG=$@
echo $ARG >> /data/local/tmp/balkava_a/proc/syscall_queue
;;
INIT)
    code=$2
    arg=$3
    # if arg starts with #, treat as number, else string
    if echo "$arg" | grep -q '^#'; then
        arg=${arg#\#}
    fi

    case "$code" in
        0) 
            echo "[INIT]: Program exited (code $arg)"
            exit "$arg"
            ;;
        1) 
            echo "[INIT]: Dumping registers"
            set | grep '^r[0-9]*='
            ;;
        2)
            echo "[INIT]: Dumping memory"
            set | grep '^mem'
            ;;
        3)
            echo "[INIT]: Hello from basmrun syscall 3!"
            ;;
        4)
            # print string arg
            if [ -n "$arg" ]; then
                echo "[INIT]: $arg"
            else
                echo "[INIT]: Nothing to print"
            fi
            ;;
        5)
            # random math demo
            r=$((RANDOM % 1000))
            echo "[INIT]: Generated random number $r"
            ;;
        *)
            echo "[INIT]: Unknown syscall $code"
            ;;
    esac
    ;;
  VLD)
    # vld vd, [addr]  -- loads 16 bytes into vector register
    IFS=',' read rd mem <<EOF
$operands
EOF
    rd=$(echo "$rd" | tr -d ' ')
    mem=$(echo "$mem" | tr -d '[] ')
    rd_idx=$(echo "$rd" | sed 's/v//')
    addr=$(expr "$mem" + 0)

    # Load 16 bytes into a space-separated string
    vreg[$rd_idx]="$(echo ${memory[@]:$addr:16})"
    ;;

VST)
    IFS=',' read rs mem <<EOF
$operands
EOF
    rs=$(echo "$rs" | tr -d ' ')
    mem=$(echo "$mem" | tr -d '[] ')
    rs_idx=$(echo "$rs" | sed 's/v//')
    addr=$(expr "$mem" + 0)

    hexstr_to_bytes "${vreg[$rs_idx]}" BYTES

    i=0
    while [ $i -lt 16 ]; do
        memory[$(expr "$addr" + $i)]="${BYTES[$i]}"
        i=$(expr $i + 1)
    done
    ;;

VSWAP)
    IFS=',' read ra rb <<EOF
$operands
EOF
    ra=$(echo "$ra" | tr -d ' ')
    rb=$(echo "$rb" | tr -d ' ')
    ia=$(echo "$ra" | sed 's/v//')
    ib=$(echo "$rb" | sed 's/v//')

    tmp="${vreg[$ia]}"
    vreg[$ia]="${vreg[$ib]}"
    vreg[$ib]="$tmp"
    ;;

VMOVN.i16)
    IFS=',' read rd rs <<EOF
$operands
EOF
    rd=$(echo "$rd" | tr -d ' ')
    rs=$(echo "$rs" | tr -d ' ')
    rd_idx=$(echo "$rd" | sed 's/v//')
    rs_idx=$(echo "$rs" | sed 's/v//')

    hexstr_to_bytes "${vreg[$rs_idx]}" SRC

    OUT=""
    i=0
    while [ $i -lt 16 ]; do
        OUT="$OUT ${SRC[$i]}"
        i=$(expr $i + 2)
    done

    # pad to 16 bytes
    while [ $(echo "$OUT" | wc -w) -lt 16 ]; do
        OUT="$OUT 00"
    done

    vreg[$rd_idx]="$OUT"
    ;;

VSHL.I8)
    IFS=',' read rd rs imm <<EOF
$operands
EOF
    rd=$(echo "$rd" | tr -d ' ')
    rs=$(echo "$rs" | tr -d ' ')
    imm=$(echo "$imm" | tr -d '#')
    rd_idx=$(echo "$rd" | sed 's/v//')
    rs_idx=$(echo "$rs" | sed 's/v//')

    hexstr_to_bytes "${vreg[$rs_idx]}" SRC

    OUT=""
    i=0
    while [ $i -lt 16 ]; do
        val=$(expr $(printf "%d" 0x${SRC[$i]}) \* $(expr 2 \*\* "$imm"))
        val=$(expr "$val" '&' 255)
        hex=$(printf "%02x" "$val")
        OUT="$OUT $hex"
        i=$(expr $i + 1)
    done

    vreg[$rd_idx]="$OUT"
    ;;

VSHRN.I16)
    IFS=',' read rd rs imm <<EOF
$operands
EOF
    rd=$(echo "$rd" | tr -d ' ')
    rs=$(echo "$rs" | tr -d ' ')
    imm=$(echo "$imm" | tr -d '#')
    rd_idx=$(echo "$rd" | sed 's/v//')
    rs_idx=$(echo "$rs" | sed 's/v//')

    hexstr_to_bytes "${vreg[$rs_idx]}" SRC

    OUT=""
    i=0
    while [ $i -lt 16 ]; do
        hi=$(printf "%d" 0x${SRC[$i+1]})
        lo=$(printf "%d" 0x${SRC[$i]})
        val=$(expr \( $hi \* 256 + $lo \) / \( 2 \*\* "$imm" \))
        val=$(expr "$val" '&' 255)
        hex=$(printf "%02x" "$val")
        OUT="$OUT $hex"
        i=$(expr $i + 2)
    done

    # pad to 16 bytes
    while [ $(echo "$OUT" | wc -w) -lt 16 ]; do
        OUT="$OUT 00"
    done

    vreg[$rd_idx]="$OUT"
    ;;
STRREPLACE)
    # args: <dst_ptr> <src_ptr> <old> <new>
    set -- $args
    dst=$1; src=$2; old=$3; new=$4
    fsrc=$(memfile "$src")
    fdst=$(memfile "$dst")
    if [ ! -f "$fsrc" ]; then
        printf "[STRREPLACE] src %s not found\n" "$src" >&2
        r0=-1
    else
        # Use sed for literal string replace; escape old/new for sed basic regex:
        esc() {
            printf '%s' "$1" | sed -e 's/[\/&]/\\&/g'
        }
        old_e=$(esc "$old")
        new_e=$(esc "$new")
        sed "s/${old_e}/${new_e}/g" "$fsrc" >"$fdst"
        r0=0
        printf "[STRREPLACE] replaced '%s' -> '%s' in %s -> %s\n" "$old" "$new" "$src" "$dst" >&2
    fi
    ;;
STREXPANDVARS)
    # args: <dst_ptr> <src_ptr> [mappings...]
    set -- $args
    dst=$1; src=$2; shift 2
    fsrc=$(memfile "$src")
    fdst=$(memfile "$dst")
    if [ ! -f "$fsrc" ]; then
        printf "[STREXPANDVARS] src %s not found\n" "$src" >&2
        r0=-1
    else
        # Start with the source content
        cp "$fsrc" "$MEMDIR/.expand_tmp"
        # process mappings: PTR:NAME:ptr
        while [ $# -gt 0 ]; do
            case "$1" in
                PTR:*)
                    # parse PTR:NAME:ptr
                    mapping="${1#PTR:}"        # NAME:ptr
                    name=$(printf '%s' "$mapping" | cut -d: -f1)
                    p=$(printf '%s' "$mapping" | cut -d: -f2-)
                    pf=$(memfile "$p")
                    if [ -f "$pf" ]; then
                        val=$(cat "$pf")
                        # escape for sed
                        esc() { printf '%s' "$1" | sed -e 's/[\/&]/\\&/g'; }
                        sed "s/\\\$$name/$(esc "$val")/g" "$MEMDIR/.expand_tmp" >"$MEMDIR/.expand_tmp2" && mv "$MEMDIR/.expand_tmp2" "$MEMDIR/.expand_tmp"
                    fi
                    ;;
                *)
                    # ignore unknown mapping form
                    ;;
            esac
            shift
        done
        if command -v envsubst >/dev/null 2>&1; then
            envsubst <"$MEMDIR/.expand_tmp" >"$fdst"
        else
            # crude fallback: replace $VAR by value from env using awk
            awk '{
                line = $0
                while (match(line, /\$[A-Za-z_][A-Za-z0-9_]*/)) {
                    var = substr(line, RSTART+1, RLENGTH-1)
                    cmd = "printf \"%s\" \"" ENVIRON[var] "\""
                    # Note: ENVIRON is nonstandard in awk; many awks support ENVIRON, but if not, shell fallback needed.
                    repl = ENVIRON[var]
                    line = substr(line, 1, RSTART-1) repl substr(line, RSTART+RLENGTH)
                }
                print line
            }' "$MEMDIR/.expand_tmp" >"$fdst"
        fi

        rm -f "$MEMDIR/.expand_tmp" "$MEMDIR/.expand_tmp2" 2>/dev/null || :
        r0=0
        printf "[STREXPANDVARS] expanded %s -> %s\n" "$src" "$dst" >&2
    fi
    ;;
STRSPLIT)
    # args: <src_ptr> <delim> <out_base_ptr>
    set -- $args
    src=$1; delim=$2; base=$3
    fsrc=$(memfile "$src")
    if [ ! -f "$fsrc" ]; then
        printf "[STRSPLIT] src %s not found\n" "$src" >&2
        r0=-1
    else
        # convert delim to literal for tr (if single char)
        # for multi-char delim, use awk
        if [ "${#delim}" -eq 1 ]; then
            # simple split on single-char delim
            tokens=$(tr "$delim" '\n' <"$fsrc")
            i=0
            while IFS= read -r line; do
                ptr=$((base + i))
                printf '%s' "$line" >"$(memfile "$ptr")"
                i=$((i+1))
            done <<EOF
$tokens
EOF
            r0=$i
            printf "[STRSPLIT] created %s tokens from %s starting at %s\n" "$r0" "$src" "$base" >&2
        else
            # multi-char delim -> awk split
            i=0
            awk -v RS="" -v ORS="\n" -v FS="$delim" '{
                for (i=1;i<=NF;i++) print $i
            }' "$fsrc" | while IFS= read -r line; do
                ptr=$((base + i))
                printf '%s' "$line" >"$(memfile "$ptr")"
                i=$((i+1))
            done
            r0=$i
        fi
    fi
    ;;
REGEXSEARCH)
    # args: <src_ptr> <regex> [all]
    set -- $args
    src=$1; regex=$2; mode=$3
    fsrc=$(memfile "$src")
    if [ ! -f "$fsrc" ]; then
        printf "[REGEXSEARCH] src %s not found\n" "$src" >&2
        r0=-1
    else
        if [ "$mode" = "all" ]; then
            # print all match byte offsets, one per line, return count in r0
            # we use awk to scan bytes; convert file to a single line preserving bytes
            # Use grep -b -o if available (most systems)
            if grep -b -o -E "$regex" "$fsrc" >/dev/null 2>&1; then
                grep -b -o -E "$regex" "$fsrc" | cut -d: -f1
                r0=$(grep -b -o -E "$regex" "$fsrc" | wc -l)
            else
                r0=0
            fi
        else
            # return first match offset (byte index) or -1
            if grep -b -o -E "$regex" "$fsrc" >/dev/null 2>&1; then
                pos=$(grep -b -o -E "$regex" "$fsrc" | head -n1 | cut -d: -f1)
                r0=$pos
            else
                r0=-1
            fi
        fi
        printf "[REGEXSEARCH] src %s regex '%s' => r0=%s\n" "$src" "$regex" "$r0" >&2
    fi
    ;;

EXPORT|ADDENV)
    # Check if NAME is provided
    if [ -z "$1" ]; then
        echo "Error: No variable name provided!" >&2
        break  # or return 1 if inside a function
    fi

    NAME=$1
    # Grab all remaining args as the value (handles spaces)
    shift
    ARGS="$*"

    # Export safely
    export "$NAME=$ARGS"
    echo "Exported: $NAME='$ARGS'"
    ;;
    BEQ|BNE|BGT|BLT|BGE|BLE) 
    # Extract label and optional offset
    label=$(echo "$args" | awk '{print $1}')
    offset=$(echo "$args" | awk '{print $2}')

    # Default: branch not taken
    branch_taken=0

    # Determine condition code
    case "$opcode" in
        BEQ) [ "$FLAG_Z" = 1 ] && branch_taken=1 ;;
        BNE) [ "$FLAG_Z" = 0 ] && branch_taken=1 ;;
        BGT) [ "$FLAG_Z" = 0 ] && [ "$FLAG_N" = "$FLAG_V" ] && branch_taken=1 ;;
        BLT) [ "$FLAG_N" != "$FLAG_V" ] && branch_taken=1 ;;
        BGE) [ "$FLAG_N" = "$FLAG_V" ] && branch_taken=1 ;;
        BLE) [ "$FLAG_Z" = 1 ] || [ "$FLAG_N" != "$FLAG_V" ] && branch_taken=1 ;;
    esac

    # Perform branch if condition met
    if [ "$branch_taken" = 1 ]; then
        if [ -n "$offset" ]; then
            # Handle signed offsets like real ASM
            pc=$((pc + offset))
        else
            pc="$label"
        fi
    fi

    # Optional: simulate pre/post-indexing updates for pseudo-registers
    if echo "$args" | grep -q "!" ; then
        REG_BASE=$((REG_BASE + 4))
    fi

    # Optional: handle multiple registers in brackets
    if echo "$args" | grep -q "\[" ; then
        REG1=$((REG1 + 1))
        REG2=$((REG2 + 1))
    fi
    ;;
    ADRP) # ADRP rDST ADDR
        r=$(echo "$args" | awk '{print $1}')
        addr=$(echo "$args" | awk '{print $2}')
        page=$(( addr & 0xFFFFFFFFFFFFF000 ))
        setreg "$r" "$page"
        ;;
        RETURN)
       CODE=$1
       exit $CODE
        ;;
        OEM_UNLCK)
        val=$(echo "$line" | awk '{print $2}')
        echo "[OEM_UNLCK]: OEM unlock flag set to $val"
        ;;

    DM_VERITY)
        val=$(echo "$line" | awk '{print $2}')
        echo "[DM_VERITY]: dm-verity state set to $val"
        ;;
MOVE)
            dest=$(echo "$2" | tr -d ','); src="$3"
            val=$(getval "$src")
            setreg "$dest" "$val"
            ;;
MOVES)
    reg="$2"
    val="$3"

    old=$(getreg "$reg")
    if [ -z "$old" ]; then old=0; fi

    # signed 32-bit handling
    if [ "$val" -ge 2147483648 ]; then
        val=$(expr "$val" - 4294967296)
    fi

    new=$(expr "$old" + "$val")
    setreg "$reg" "$new"
    ;;

MOVEU)
    reg="$2"
    val="$3"

    old=$(getreg "$reg")
    if [ -z "$old" ]; then old=0; fi

    # force unsigned 32-bit mask
    old_masked=$(expr "$old" '&' 4294967295)
    val_masked=$(expr "$val" '&' 4294967295)
    new=$(expr "$old_masked" '|' "$val_masked")
    setreg "$reg" "$new"
    ;;

MOVEB)
    reg="$2"
    val="$3"

    old=$(getreg "$reg")
    if [ -z "$old" ]; then old=0; fi

    mask=$(expr 4294967295 - 255)
    new=$(expr "$old" '&' "$mask" '|' "$val" '&' 255)
    setreg "$reg" "$new"
    ;;

MOVEH)
    reg="$2"
    val="$3"

    old=$(getreg "$reg")
    if [ -z "$old" ]; then old=0; fi

    mask=$(expr 4294967295 - 65535)
    new=$(expr "$old" '&' "$mask" '|' "$val" '&' 65535)
    setreg "$reg" "$new"
    ;;

MOVEL)
    reg="$2"
    val="$3"

    new=$(expr "$val" '&' 4294967295)
    setreg "$reg" "$new"
    ;;

MOVEH32)
    reg="$2"
    val="$3"

    # POSIX-safe 32-bit shift
    high=$(expr "$val" / 4294967296)
    new=$(expr "$high" '&' 4294967295)
    setreg "$reg" "$new"
    ;;

MOVEPTR)
    reg="$2"
    ptr="$3"

    setreg "$reg" "$ptr"
    ;;

MOVEADDR)
    reg="$2"
    addr="$3"

    if [ "$addr" -ge 0 ] && [ "$addr" -le 4294967295 ]; then
        setreg "$reg" "$addr"
    fi
    ;;

MOVX)
    reg="$2"
    val="$3"

    setreg "$reg" "$val"
    ;;
MOVEK)
    reg="$2"       # r1
    imm="$3"       # 0x2
    shift="$4"     # 64

    old=$(getreg "$reg")
    if [ -z "$old" ]; then old=0; fi

    # compute mask = ~((1 << shift) - 1)
    # 1 << shift = 2^shift
    one_shift=$(expr 1 \* 1)
    pow=1
    i=0
    while [ "$i" -lt "$shift" ]; do
        pow=$(expr "$pow" \* 2)
        i=$(expr "$i" + 1)
    done
    mask=$(expr 4294967295 - "$pow" + 1)

    # imm << shift = imm * 2^shift
    imm_shifted=$(expr "$imm" \* "$pow")

    # combine with old value
    new=$(expr "$old" '&' "$mask" '|' "$imm_shifted")
    setreg "$reg" "$new"
    ;;
        ADD|SUB|MUL|DIV|AND|OR|XOR)
            dest=$(echo "$2" | tr -d ','); a=$(echo "$3" | tr -d ','); b="$4"
            va=$(getval "$a"); vb=$(getval "$b")
            case "$instr" in
                ADD) res=$((va + vb));;
                SUB) res=$((va - vb));;
                MUL) res=$((va * vb));;
                DIV) [ "$vb" -ne 0 ] && res=$((va / vb)) || res=0;;
                AND) res=$((va & vb));;
                OR)  res=$((va | vb));;
                XOR) res=$((va ^ vb));;
            esac
            setreg "$dest" "$res"
            ;;
        NOT)
            dest=$(echo "$2" | tr -d ','); src="$3"
            va=$(getval "$src"); res=$((~va))
            setreg "$dest" "$res"
            ;;
       CLREX)
        echo "[CLREX]: clear exclusive monitor"
        ;;

    LDAXR)
        reg=$(echo "$line" | awk '{print $2}')
        addr=$(echo "$line" | awk '{print $3}')
        echo "[LDAXR]: load‑acquire exclusive from $addr into $reg"
        ;;
     UNLCK)
        val=$(echo "$line" | awk '{print $2}')
        if [ "$val" -eq 1 ]; then
        echo "warning bootloader is unlocked, your balkava vm altered and voided waranty"
        else
        echo " "
        fi
        ;;
        AVB)
        val=$(echo "$line" | awk '{print $2}')
        if [ "$val" -eq 1 ]; then
            echo "[AVB]: Android Verified Boot enabled"
        else
            echo "[AVB]: AVB disabled"
        fi
        ;;

    BYPASS_AVB)
        val=$(echo "$line" | awk '{print $2}')
        if [ "$val" -eq 1 ]; then
            echo "⚠️  AVB BYPASS ACTIVE: booting even with invalid vbmeta"
        else
            echo "[BYPASS_AVB]: bypass disabled"
        fi
        ;;
    UNLCK_CRITPAR)
        val=$(echo "$line" | awk '{print $2}')
        if [ "$val" -eq 1 ]; then
        echo "warning: critical partition are unlock and altered"
        else
        echo " "
        fi
        ;;
        PRINTL|LOOP-PRINT)
        while true; do
        text=$(echo "$line" | sed 's/^[^"]*"//;s/"$//')
        echo "$text"
        sleep 0.1
        done
        ;;
       WATCH-PRINT|PRINTW)
       while true; do
    text=$(echo "$line" | sed 's/^[^"]*"//;s/"$//')  # Clean quotes
    clear                                           # Clear terminal
    echo "$text"                                    # Print text
    sleep 0.7
done
;;
    STLXR)
        reg=$(echo "$line" | awk '{print $2}')
        addr=$(echo "$line" | awk '{print $3}')
        echo "[STLXR]: store‑release exclusive $reg to $addr"
        ;;
       DC)
    subop=$(echo "$line" | awk '{print $2}')
    case "$subop" in
      CIVAC)
        addr=$(echo "$line" | awk '{print $3}')
        echo "[DC CIVAC]: clean & invalidate data cache line VA=$addr"
        ;;
      ZVA)
        addr=$(echo "$line" | awk '{print $3}')
        echo "[DC ZVA]: zero data cache line VA=$addr"
        ;;
    esac
    ;;
IC)
    subop=$(echo "$line" | awk '{print $2}')
    case "$subop" in
      IALLU)
        echo "[IC IALLU]: invalidate all instruction caches to PoU"
        ;;
      IVAU)
        addr=$(echo "$line" | awk '{print $3}')
        echo "[IC IVAU]: invalidate instruction cache line VA=$addr"
        ;;
    esac
    ;;
TLBI)
    subop=$(echo "$line" | awk '{print $2}')
    case "$subop" in
      VMALLE1)
        echo "[TLBI VMALLE1]: invalidate all stage 1 translations EL1"
        ;;
    esac
    ;;
        SQRT)
        reg=$(echo "$line" | awk '{print $2}')
        echo "[SQRT]: square root into $reg"
        ;;

    ABS)
        reg=$(echo "$line" | awk '{print $2}')
        echo "[ABS]: absolute value of $reg"
        ;;
LDAXP)
        reg1=$(echo "$line" | awk '{print $2}')
        reg2=$(echo "$line" | awk '{print $3}')
        addr=$(echo "$line" | awk '{print $4}')
        echo "[LDAXP]: load-acquire exclusive pair from $addr into $reg1, $reg2"
        ;;

    STLXP)
        reg1=$(echo "$line" | awk '{print $2}')
        reg2=$(echo "$line" | awk '{print $3}')
        addr=$(echo "$line" | awk '{print $4}')
        echo "[STLXP]: store-release exclusive pair $reg1, $reg2 to $addr"
        ;;
DMB\ SY)
        echo "[DMB SY]: data memory barrier, shareable domain"
        ;;

    DSB\ SY)
        echo "[DSB SY]: data synchronization barrier, shareable domain"
        ;;

    ISB)
        echo "[ISB]: instruction synchronization barrier"
        ;;
        FMADD)
        regd=$(echo "$line" | awk '{print $2}')
        regn=$(echo "$line" | awk '{print $3}')
        regm=$(echo "$line" | awk '{print $4}')
        rega=$(echo "$line" | awk '{print $5}')
        echo "[FMADD]: fused multiply-add $regn * $regm + $rega → $regd"
        ;;

    FMSUB)
        regd=$(echo "$line" | awk '{print $2}')
        regn=$(echo "$line" | awk '{print $3}')
        regm=$(echo "$line" | awk '{print $4}')
        rega=$(echo "$line" | awk '{print $5}')
        echo "[FMSUB]: fused multiply-sub $regn * $regm - $rega → $regd"
        ;;

    FCVT)
        regd=$(echo "$line" | awk '{print $2}')
        regn=$(echo "$line" | awk '{print $3}')
        echo "[FCVT]: convert float $regn → int $regd"
        ;;

    RBIT)
        reg=$(echo "$line" | awk '{print $2}')
        echo "[RBIT]: reverse bits in $reg"
        ;;

    REV)
        reg=$(echo "$line" | awk '{print $2}')
        echo "[REV]: reverse byte order in $reg"
        ;;

    CLZ)
        reg=$(echo "$line" | awk '{print $2}')
        echo "[CLZ]: count leading zeros in $reg"
        ;;

    AESENC)
        reg=$(echo "$line" | awk '{print $2}')
        round=$(echo "$line" | awk '{print $3}')
        echo "[AESENC]: AES encrypt $reg with round $round"
        ;;

    AESDEC)
        reg=$(echo "$line" | awk '{print $2}')
        round=$(echo "$line" | awk '{print $3}')
        echo "[AESDEC]: AES decrypt $reg with round $round"
        ;;

    SHA1C)
        reg=$(echo "$line" | awk '{print $2}')
        echo "[SHA1C]: compute SHA1 cycle with $reg"
        ;;
        SHL|SHR)
            dest=$(echo "$2" | tr -d ','); a=$(echo "$3" | tr -d ','); b="$4"
            va=$(getval "$a"); vb=$(getval "$b")
            case "$instr" in
                SHL) res=$((va << vb));;
                SHR) res=$((va >> vb));;
            esac
            setreg "$dest" "$res"
            ;;
        CMP)
            a=$(echo "$2" | tr -d ','); b="$3"
            va=$(getval "$a"); vb=$(getval "$b")
            if [ "$va" -eq "$vb" ]; then last_cmp=0
            elif [ "$va" -lt "$vb" ]; then last_cmp=-1
            else last_cmp=1; fi
            ;;
        JE|JNE|JL|JG|JLE|JGE|JMP|CALL)
            label=$2
            jump=0
            case "$instr" in
                JMP) jump=1;;
                CALL) jump=1; echo "$pc" >> "$stack_file";;
                JE)  [ "$last_cmp" -eq 0 ] && jump=1;;
                JNE) [ "$last_cmp" -ne 0 ] && jump=1;;
                JL)  [ "$last_cmp" -eq -1 ] && jump=1;;
                JG)  [ "$last_cmp" -eq 1 ] && jump=1;;
                JLE) [ "$last_cmp" -eq -1 ] || [ "$last_cmp" -eq 0 ] && jump=1;;
                JGE) [ "$last_cmp" -eq 1 ] || [ "$last_cmp" -eq 0 ] && jump=1;;
            esac
            if [ $jump -eq 1 ]; then
                pc=$(( $(eval echo "\$label_$label") + 1 ))
                last_jump=1
            else
                last_jump=0
            fi
           ;;
BIC)  # Bitwise AND NOT
    args_arr=($args)
    reg=${args_arr[0]}
    val=${args_arr[1]}
    eval "$reg=\$(( $reg & (~$val) ))"
    ;;

EOR)  # Bitwise XOR
    args_arr=($args)
    reg=${args_arr[0]}
    val=${args_arr[1]}
    eval "$reg=\$(( $reg ^ $val ))"
    ;;
LSL)  # Logical Shift Left
    args_arr=($args)
    reg=${args_arr[0]}
    val=${args_arr[1]}
    eval "$reg=\$(( $reg << $val ))"
    ;;

LSR)  # Logical Shift Right
    args_arr=($args)
    reg=${args_arr[0]}
    val=${args_arr[1]}
    eval "$reg=\$(( $reg >> $val ))"
    ;;

ASR)  # Arithmetic Shift Right
    args_arr=($args)
    reg=${args_arr[0]}
    val=${args_arr[1]}
    # preserve sign for negative numbers
    eval "$reg=\$(( ( $reg >> $val ) | ( ( $reg & 0x80000000 ) * ( (1 << $val) - 1 ) ) ))"
    ;;

ROR)  # Rotate Right
    args_arr=($args)
    reg=${args_arr[0]}
    val=${args_arr[1]}
    eval "$reg=\$(( ( $reg >> $val ) | ( $reg << (32 - $val) & 0xFFFFFFFF ) ))"
    ;;

MALLOC)
    # args: <size>
    set -- $args
    size=$1
    ptr=$(expr $PTR_COUNTER + 1)
    PTR_COUNTER=$ptr
    f=$(memfile "$ptr")
    dd if=/dev/zero of="$f" bs=1 count="$size" 2>/dev/null || :
    r0=$ptr
    printf "[MALLOC] %s bytes -> ptr %s\n" "$size" "$ptr" >&2
    ;;

FREE)
    set -- $args
    ptr=$1
    f=$(memfile "$ptr")
    if [ -f "$f" ]; then
        rm -f "$f"
        printf "[FREE] freed ptr %s\n" "$ptr" >&2
    else
        printf "[FREE] ptr %s not found\n" "$ptr" >&2
    fi
    ;;

WRITEMEM)
    set -- $args
    ptr=$1
    shift
    val="$*"
    f=$(memfile "$ptr")
    : > "$f"
    printf '%s' "$val" > "$f"
    printf "[WRITEMEM] wrote %s bytes to %s\n" "$(printf '%s' "$val" | wc -c | tr -d ' ')" "$ptr" >&2
    ;;

READMEM)
    set -- $args
    ptr=$1
    len=$2
    f=$(memfile "$ptr")
    if [ ! -f "$f" ]; then
        r0=""
        printf "[MEMREAD] ptr %s not found\n" "$ptr" >&2
    else
        r0=$(dd if="$f" bs=1 count="$len" 2>/dev/null)
        printf "[MEMREAD] read %s bytes from %s\n" "$(printf '%s' "$r0" | wc -c | tr -d ' ')" "$ptr" >&2
    fi
    ;;

MEMCPY)
    set -- $args
    dst=$1
    src=$2
    nbytes=$3
    fdst=$(memfile "$dst")

    if [ -f "$(memfile "$src")" ]; then
        fsrc=$(memfile "$src")
        dd if="$fsrc" of="$fdst" bs=1 count="$nbytes" conv=notrunc 2>/dev/null
    else
        printf "%.*s" "$nbytes" "$src" | dd of="$fdst" bs=1 conv=notrunc 2>/dev/null
    fi
    r0=0
    printf "[MEMCPY] copied %s bytes from %s -> %s\n" "$nbytes" "$src" "$dst" >&2
    ;;

MEMSET)
    set -- $args
    ptr=$1
    byte=$2
    len=$3
    f=$(memfile "$ptr")

    case "$byte" in
        ''|*[!0-9]*)
            ch=$(printf '%s' "$byte" | cut -c1)
            ;;
        *)
            ch=$(printf "\\$(printf '%03o' "$byte")")
            ;;
    esac

    dd if=/dev/zero bs=1 count="$len" 2>/dev/null | tr '\0' "$ch" > "$f"
    printf "[MEMSET] set %s bytes at %s to byte '%s'\n" "$len" "$ptr" "$byte" >&2
    ;;

STRLEN)
    set -- $args
    ptr=$1
    f=$(memfile "$ptr")
    if [ ! -f "$f" ]; then
        r0=0
    else
        r0=$(wc -c < "$f" | tr -d ' ')
    fi
    printf "[STRLEN] ptr %s length %s\n" "$ptr" "$r0" >&2
    ;;

STRCMP)
    set -- $args
    p1=$1
    p2=$2
    f1=$(memfile "$p1")
    f2=$(memfile "$p2")
    if [ ! -f "$f1" ] || [ ! -f "$f2" ]; then
        r0=1
    else
        cmp -s "$f1" "$f2"
        r0=$?
    fi
    printf "[STRCMP] result %s\n" "$r0" >&2
    ;;
MEMSLICE)
    # args: <src_ptr> <offset> <len>
    set -- $args
    src=$1
    off=$2
    len=$3
    fsrc=$(memfile "$src")
    if [ ! -f "$fsrc" ]; then
        printf "[MEMSLICE] src %s not found\n" "$src" >&2
        r0=0
    else
        ptr=`expr $PTR_COUNTER + 1`
        PTR_COUNTER=$ptr
        fdst=$(memfile "$ptr")
        dd if="$fsrc" of="$fdst" bs=1 skip="$off" count="$len" 2>/dev/null || :
        r0=$ptr
        printf "[MEMSLICE] created ptr %s slice of %s@%s len %s\n" "$ptr" "$src" "$off" "$len" >&2
    fi
    ;;

HEXDUMP)
    set -- $args
    ptr=$1
    len=$2
    f=$(memfile "$ptr")
    if [ ! -f "$f" ]; then
        printf "[HEXDUMP] ptr %s not found\n" "$ptr" >&2
    else
        dd if="$f" bs=1 count="$len" 2>/dev/null | od -An -tx1 | tr -s ' ' | sed 's/^ //;s/ $//'
    fi
    ;;

MEMWRITEHEX)
    set -- $args
    ptr=$1
    shift
    hex="$*"
    f=$(memfile "$ptr")
    : > "$f"
    i=1
    while [ $i -le ${#hex} ]; do
        h=`echo "$hex" | cut -c $i-$((i+1))`
        # POSIX printf hex to byte
        printf "\\\x$h" >> "$f"
        i=`expr $i + 2`
    done
    printf "[MEMWRITEHEX] wrote `wc -c <"$f" | tr -d ' '` bytes to %s\n" "$ptr" >&2
    ;;

MEMWRITEBIN)
    set -- $args
    ptr=$1
    srcfile=$2
    f=$(memfile "$ptr")
    if [ ! -f "$srcfile" ]; then
        printf "[MEMWRITEBIN] source %s not found\n" "$srcfile" >&2
    else
        cp "$srcfile" "$f"
        printf "[MEMWRITEBIN] wrote %s -> %s (%s bytes)\n" "$srcfile" "$ptr" "`wc -c <"$f" | tr -d ' '`" >&2
    fi
    ;;

MEMDUMP)
    set -- $args
    ptr=$1
    len=$2
    outfile=$3
    f=$(memfile "$ptr")
    if [ ! -f "$f" ]; then
        printf "[MEMDUMP] ptr %s not found\n" "$ptr" >&2
    else
        dd if="$f" of="$outfile" bs=1 count="$len" 2>/dev/null || :
        printf "[MEMDUMP] dumped %s bytes from %s -> %s\n" "$len" "$ptr" "$outfile" >&2
    fi
    ;;

HEXLEN)
    set -- $args
    ptr=$1
    f=$(memfile "$ptr")
    if [ -f "$f" ]; then
        r0=`wc -c <"$f" | tr -d ' '`
    else
        r0=0
    fi
    printf "[HEXLEN] ptr %s length %s\n" "$ptr" "$r0" >&2
    ;;

MEMROTATE)
    set -- $args
    ptr=$1
    len=$2
    dir=$3
    count=$4
    f=$(memfile "$ptr")
    if [ ! -f "$f" ]; then
        r0=0
    else
        dd if="$f" bs=1 count="$len" 2>/dev/null >"$MEMDIR/rotbuf"
        case "$dir" in
            L)
                dd if="$MEMDIR/rotbuf" bs=1 skip="$count" 2>/dev/null >"$MEMDIR/rotout"
                dd if="$MEMDIR/rotbuf" bs=1 count="$count" 2>/dev/null >>"$MEMDIR/rotout"
                ;;
            R)
                off=`expr $len - $count`
                dd if="$MEMDIR/rotbuf" bs=1 skip="$off" 2>/dev/null >"$MEMDIR/rotout"
                dd if="$MEMDIR/rotbuf" bs=1 count="$off" 2>/dev/null >>"$MEMDIR/rotout"
                ;;
        esac
        mv "$MEMDIR/rotout" "$f"
        rm -f "$MEMDIR/rotbuf"
        r0=$len
        printf "[MEMROTATE] rotated %s bytes %s by %s\n" "$len" "$dir" "$count" >&2
    fi
    ;;

MEMCMPN)
    set -- $args
    p1=$1
    p2=$2
    len=$3
    f1=$(memfile "$p1")
    f2=$(memfile "$p2")
    if [ -f "$f1" ] && [ -f "$f2" ]; then
        dd if="$f1" bs=1 count="$len" 2>/dev/null >"$MEMDIR/c1"
        dd if="$f2" bs=1 count="$len" 2>/dev/null >"$MEMDIR/c2"
        cmp -s "$MEMDIR/c1" "$MEMDIR/c2"
        if [ $? -eq 0 ]; then
            r0=0
        else
            r0=1
        fi
        rm -f "$MEMDIR/c1" "$MEMDIR/c2"
    else
        r0=-1
    fi
    ;;

MEMMOVE)
    set -- $args
    dst=$1
    src=$2
    len=$3
    fdst=$(memfile "$dst")
    fsrc=$(memfile "$src")
    if [ ! -f "$fsrc" ]; then
        printf "[MEMMOVE] src %s not found\n" "$src" >&2
        r0=0
    else
        tmp=`mktemp`
        dd if="$fsrc" bs=1 count="$len" 2>/dev/null >"$tmp"
        dd if="$tmp" of="$fdst" bs=1 count="$len" conv=notrunc 2>/dev/null
        rm -f "$tmp"
        r0=$len
        printf "[MEMMOVE] moved %s bytes from %s -> %s (safe)\n" "$len" "$src" "$dst" >&2
    fi
    ;;

MEMZERO)
    set -- $args
    ptr=$1
    len=$2
    f=$(memfile "$ptr")
    : > "$f"
    dd if=/dev/zero of="$f" bs=1 count="$len" 2>/dev/null
    r0=$len
    printf "[MEMZERO] zeroed %s bytes at %s\n" "$len" "$ptr" >&2
    ;;

MEMSCAN)
    set -- $args
    ptr=$1
    byte=$2
    len=$3
    f=$(memfile "$ptr")
    if [ ! -f "$f" ]; then
        printf "[MEMSCAN] ptr %s not found\n" "$ptr" >&2
        r0=-1
    else
        dd if="$f" bs=1 count="$len" 2>/dev/null | od -An -tx1 | tr -s ' ' | \
        awk -v target="$byte" '{
            for(i=1;i<=NF;i++){if($i==target){print NR+i-2; exit}}
        }' >"$MEMDIR/scanres"
        if [ -s "$MEMDIR/scanres" ]; then
            r0=`cat "$MEMDIR/scanres"`
        else
            r0=-1
        fi
        rm -f "$MEMDIR/scanres"
    fi
    ;;

MEMRCHR)
    set -- $args
    ptr=$1
    byte=$2
    len=$3
    f=$(memfile "$ptr")
    if [ ! -f "$f" ]; then
        r0=-1
    else
        dd if="$f" bs=1 count="$len" 2>/dev/null | od -An -tx1 | tr -s ' ' | \
        awk -v target="$byte" '{
            for(i=NF;i>=1;i--){if($i==target){print NR+i-2; exit}}
        }' >"$MEMDIR/scanres"
        if [ -s "$MEMDIR/scanres" ]; then
            r0=`cat "$MEMDIR/scanres"`
        else
            r0=-1
        fi
        rm -f "$MEMDIR/scanres"
    fi
    ;;

MEMSWAP)
    set -- $args
    p1=$1
    p2=$2
    len=$3
    f1=$(memfile "$p1")
    f2=$(memfile "$p2")
    tmp=`mktemp`
    if [ -f "$f1" ] && [ -f "$f2" ]; then
        dd if="$f1" bs=1 count="$len" 2>/dev/null >"$tmp"
        dd if="$f2" bs=1 count="$len" 2>/dev/null of="$f1" conv=notrunc
        dd if="$tmp" bs=1 count="$len" 2>/dev/null of="$f2" conv=notrunc
        r0=$len
        printf "[MEMSWAP] swapped %s bytes between %s and %s\n" "$len" "$p1" "$p2" >&2
    else
        r0=0
    fi
    rm -f "$tmp"
    ;;
STRCPY)
    set -- $args
    dst=$1
    src=$2
    fsrc=$(memfile "$src")
    fdst=$(memfile "$dst")
    if [ -f "$fsrc" ]; then
        cp "$fsrc" "$fdst"
        r0=0
        printf "[STRCPY] copied string from %s -> %s\n" "$src" "$dst" >&2
    else
        r0=-1
    fi
    ;;

STRNCPY)
    set -- $args
    dst=$1
    src=$2
    n=$3
    fsrc=$(memfile "$src")
    fdst=$(memfile "$dst")
    if [ -f "$fsrc" ]; then
        dd if="$fsrc" of="$fdst" bs=1 count="$n" 2>/dev/null || :
        r0=0
        printf "[STRNCPY] copied %s chars from %s -> %s\n" "$n" "$src" "$dst" >&2
    else
        r0=-1
    fi
    ;;

STRCAT)
    set -- $args
    dst=$1
    src=$2
    fsrc=$(memfile "$src")
    fdst=$(memfile "$dst")
    if [ -f "$fsrc" ] && [ -f "$fdst" ]; then
        cat "$fsrc" >>"$fdst"
        r0=0
        printf "[STRCAT] appended %s -> %s\n" "$src" "$dst" >&2
    else
        r0=-1
    fi
    ;;

STRLEN)
    ptr=$args
    f=$(memfile "$ptr")
    if [ -f "$f" ]; then
        r0=`wc -c <"$f" | tr -d ' '`
        printf "[STRLEN] length of %s = %s\n" "$ptr" "$r0" >&2
    else
        r0=-1
    fi
    ;;

STRCMP)
    set -- $args
    p1=$1
    p2=$2
    f1=$(memfile "$p1")
    f2=$(memfile "$p2")
    if [ -f "$f1" ] && [ -f "$f2" ]; then
        cmp -s "$f1" "$f2"
        if [ $? -eq 0 ]; then
            r0=0
        else
            r0=1
        fi
        printf "[STRCMP] compared %s and %s => %s\n" "$p1" "$p2" "$r0" >&2
    else
        r0=-1
    fi
    ;;

STRSTR)
    set -- $args
    hay=$1
    nee=$2
    fh=$(memfile "$hay")
    fn=$(memfile "$nee")
    if [ -f "$fh" ] && [ -f "$fn" ]; then
        needle=`cat "$fn"`
        pos=`grep -b -o "$needle" "$fh" | head -n1 | cut -d: -f1`
        if [ -n "$pos" ]; then
            r0=$pos
        else
            r0=-1
        fi
        printf "[STRSTR] searched for %s in %s => %s\n" "$nee" "$hay" "$r0" >&2
    else
        r0=-1
    fi
    ;;

STRREV)
    ptr=$args
    f=$(memfile "$ptr")
    if [ -f "$f" ]; then
        rev "$f" >"$MEMDIR/revtmp"
        mv "$MEMDIR/revtmp" "$f"
        r0=0
        printf "[STRREV] reversed string at %s\n" "$ptr" >&2
    else
        r0=-1
    fi
    ;;

STRUPPER)
    ptr=$args
    f=$(memfile "$ptr")
    if [ -f "$f" ]; then
        tr '[:lower:]' '[:upper:]' <"$f" >"$MEMDIR/uptmp"
        mv "$MEMDIR/uptmp" "$f"
        r0=0
        printf "[STRUPPER] uppercased string at %s\n" "$ptr" >&2
    else
        r0=-1
    fi
    ;;

STRLOWER)
    ptr=$args
    f=$(memfile "$ptr")
    if [ -f "$f" ]; then
        tr '[:upper:]' '[:lower:]' <"$f" >"$MEMDIR/lowtmp"
        mv "$MEMDIR/lowtmp" "$f"
        r0=0
        printf "[STRLOWER] lowercased string at %s\n" "$ptr" >&2
    else
        r0=-1
    fi
    ;;

STRTRIM)
    ptr=$args
    f=$(memfile "$ptr")
    if [ -f "$f" ]; then
        sed -e 's/^[ \t]*//' -e 's/[ \t]*$//' "$f" >"$MEMDIR/trmtmp"
        mv "$MEMDIR/trmtmp" "$f"
        r0=0
        printf "[STRTRIM] trimmed spaces at %s\n" "$ptr" >&2
    else
        r0=-1
    fi
    ;;

STRTOK)
    set -- $args
    ptr=$1
    delim=$2
    idx=$3
    f=$(memfile "$ptr")
    if [ -f "$f" ]; then
        token=`tr "$delim" '\n' <"$f" | sed -n "$((idx + 1))p"`
        if [ -n "$token" ]; then
            echo "$token" >"$MEMDIR/toktmp"
            r0=`expr $MEMBASE + 9000`
            ln -sf "$MEMDIR/toktmp" "$(memfile "$r0")"
        else
            r0=-1
        fi
        printf "[STRTOK] split %s by '%s', index %s => %s\n" "$ptr" "$delim" "$idx" "$r0" >&2
    else
        r0=-1
    fi
    ;;

STRPAD)
    set -- $args
    ptr=$1
    padchar=$2
    len=$3
    side=$4
    f=$(memfile "$ptr")
    if [ -f "$f" ]; then
        cur=`cat "$f"`
        cur_len=`printf "%s" "$cur" | wc -c | tr -d ' '`
        if [ "$cur_len" -lt "$len" ]; then
            pad=""
            i=1
            while [ $i -le `expr $len - $cur_len` ]; do
                pad="$pad$padchar"
                i=`expr $i + 1`
            done
            if [ "$side" = "L" ]; then
                printf "%s%s" "$pad" "$cur" >"$f"
            else
                printf "%s%s" "$cur" "$pad" >"$f"
            fi
        fi
        r0=0
        printf "[STRPAD] padded string at %s to len=%s\n" "$ptr" "$len" >&2
    else
        r0=-1
    fi
    ;;

STRCHR)
    set -- $args
    ptr=$1
    c=$2
    f=$(memfile "$ptr")
    if [ -f "$f" ]; then
        pos=`awk -v c="$c" '{
            for(i=1;i<=length($0);i++){if(substr($0,i,1)==c){print i-1; exit}}
        }' "$f"`
        if [ -n "$pos" ]; then
            r0=$pos
        else
            r0=-1
        fi
        printf "[STRCHR] searched for '%s' in %s => %s\n" "$c" "$ptr" "$r0" >&2
    else
        r0=-1
    fi
    ;;

STRRCHR)
    set -- $args
    ptr=$1
    c=$2
    f=$(memfile "$ptr")
    if [ -f "$f" ]; then
        pos=`awk -v c="$c" '{
            for(i=length($0);i>=1;i--){if(substr($0,i,1)==c){print i-1; exit}}
        }' "$f"`
        if [ -n "$pos" ]; then
            r0=$pos
        else
            r0=-1
        fi
        printf "[STRRCHR] searched for last '%s' in %s => %s\n" "$c" "$ptr" "$r0" >&2
    else
        r0=-1
    fi
    ;;
LDA)  # Load Accumulator
    case "$args" in
        \#*) ACC=`echo "$args" | sed 's/#//'` ;;
        *) addr=`echo "$args" | sed 's/\[//;s/\]//'`
           ACC=${MEMORY[$addr]} ;;
    esac
    ;;

LDX)  # Load X register
    case "$args" in
        \#*) X=`echo "$args" | sed 's/#//'` ;;
        *) addr=`echo "$args" | sed 's/\[//;s/\]//'`
           X=${MEMORY[$addr]} ;;
    esac
    ;;

LDY)  # Load Y register
    case "$args" in
        \#*) Y=`echo "$args" | sed 's/#//'` ;;
        *) addr=`echo "$args" | sed 's/\[//;s/\]//'`
           Y=${MEMORY[$addr]} ;;
    esac
    ;;

STA)  # Store Accumulator
    addr=`echo "$args" | sed 's/\[//;s/\]//'`
    MEMORY[$addr]=$ACC
    ;;

STX)  # Store X
    addr=`echo "$args" | sed 's/\[//;s/\]//'`
    MEMORY[$addr]=$X
    ;;

STY)  # Store Y
    addr=`echo "$args" | sed 's/\[//;s/\]//'`
    MEMORY[$addr]=$Y
    ;;

ADC)  # Add with carry
    case "$args" in
        \#*) val=`echo "$args" | sed 's/#//'` ;;
        *) addr=`echo "$args" | sed 's/\[//;s/\]//'`
           val=${MEMORY[$addr]} ;;
    esac
    ACC=`expr $ACC + $val + $CARRY`
    if [ "$ACC" -eq 0 ]; then FLAG_Z=1; else FLAG_Z=0; fi
    FLAG_N=`expr $ACC / 128`  # if top bit set, FLAG_N=1 else 0
    ;;

SBC)  # Subtract with borrow
    case "$args" in
        \#*) val=`echo "$args" | sed 's/#//'` ;;
        *) addr=`echo "$args" | sed 's/\[//;s/\]//'`
           val=${MEMORY[$addr]} ;;
    esac
    ACC=`expr $ACC - $val - \( 1 - $CARRY \)`
    if [ "$ACC" -eq 0 ]; then FLAG_Z=1; else FLAG_Z=0; fi
    FLAG_N=`expr $ACC / 128`
    ;;

JSR)  # Jump to subroutine
    stack[$stack_ptr]=$pc
    stack_ptr=`expr $stack_ptr + 1`
    pc=`echo "$args" | awk '{print $1}'`
    ;;

RTS)  # Return from subroutine
    stack_ptr=`expr $stack_ptr - 1`
    pc=${stack[$stack_ptr]}
    ;;

BEQ_6502) # Branch if equal
    offset=`echo "$args" | awk '{print $1}'`
    if [ "$FLAG_Z" -eq 1 ]; then
        pc=`expr $pc + $offset`
    fi
    ;;

BNE_6502) # Branch if not equal
    offset=`echo "$args" | awk '{print $1}'`
    if [ "$FLAG_Z" -eq 0 ]; then
        pc=`expr $pc + $offset`
    fi
    ;;
#----------- fake hardware/low level things for my hardware stimulations ------------------

FIND_IN_BLK)
BOOTFLOWST_MEDIA="MEDIA"
BOOTFLOWST_PART="PART"
BOOTFLOWST_FS="FS"
BOOTFLOWIF_SINGLE_PARTITION=1
BOOTFLOWIF_ONLY_BOOTABLE=2
MAX_PART_PER_BOOTDEV=90

dev_name="$1"       # simulated dev name
blk_name="$2"       # simulated block dev name
method="$3"         # simulated boot method
iter_part="$4"      # current partition index
iter_flags="$5"     # flags (single partition, only bootable)
allow_any_part="$6" # "1" if allowed, "0" otherwise

# sanity check
if [ "$iter_part" -ge "$MAX_PART_PER_BOOTDEV" ]; then
    log_msg_ret "max" 255
    return
fi

if [ "$iter_part" -ne 0 ]; then
    partstr="part_$iter_part"
else
    partstr="whole"
fi

bflow_name="${dev_name}.${partstr}"
bflow_part="$iter_part"
bflow_state=""

# fake check
log_debug "bootmeth_check $method part=$iter_part"
# pretend bootmeth_check passed

# fake part_get_info simulation
ret=0
log_debug "part_get_info() returned $ret"

if [ "$ret" -eq 95 ]; then
    log_msg_ret "part" 108
    return
fi

if [ "$ret" -ne 0 ] && [ "$allow_any_part" -eq 0 ]; then
    if [ "$iter_part" -eq 1 ]; then
        iter_max_part=3
        ret=2
    fi
    log_msg_ret "part" "$ret"
    return
fi

iter_max_part="$MAX_PART_PER_BOOTDEV"

single_partition_flag=`expr "$iter_flags" \& "$BOOTFLOWIF_SINGLE_PARTITION"`
only_bootable_flag=`expr "$iter_flags" \& "$BOOTFLOWIF_ONLY_BOOTABLE"`

if [ "$single_partition_flag" -ne 0 ]; then
    log_debug "single partition mode"
else
    if [ "$iter_part" -eq 0 ]; then
        first_bootable=1
        log_debug "checking bootable=$first_bootable"
    else
        if [ "$allow_any_part" -eq 1 ]; then
            log_debug "allow_any_part skipping checks"
        else
            if [ "$only_bootable_flag" -ne 0 ]; then
                # fake skip logic
                log_debug "Skipping non-bootable partition $iter_part"
                log_msg_ret "boot" 22
                return
            else
                # pretend fs_set_blk_dev_with_part worked
                ret=0
                bflow_state="$BOOTFLOWST_PART"
                if [ "$ret" -ne 0 ]; then
                    log_msg_ret "fs" "$ret"
                    return
                fi
                log_debug "$blk_name: Found partition $bflow_part type=FAKE fstype=ext4"
                bflow_state="$BOOTFLOWST_FS"
            fi
        fi
    fi
fi

log_debug "method $method"

# simulate bootmeth_read_bootflow
ret=0
if [ "$ret" -ne 0 ]; then
    log_msg_ret "method" "$ret"
    return
fi

echo "S: success -> dev=$dev_name blk=$blk_name part=$bflow_part state=$bflow_state"
;;
    READ_ROOT)
    if [ -d /data/local/tmp/balkava_a ]; then
    echo
    else
    echo "E: BALKAVA OS ROOT DIRECTORY NOT FOUND"
    echo "System halted"
    exit 1
    fi
        ;;
    READ_PART)
    partition=$2
    part_path="/data/local/tmp/balkava_a/$partition"
if [ -z "$partition" ]; then
    echo ""
fi
    if [ -d "$part_path" ]; then
        echo "$partition"
    else
        echo "E: Partition $partition not found!"
     fi
    ;;

# READPARTSIZE <expected_size> <partition_name>
READPARTSIZE)
    expected_size=$1
    partition=$2
    partition_path="/data/local/tmp/balkava_a/$partition"

    # Convert human-readable (KB/MB/GB) into bytes
    case "$expected_size" in
        *KB) num=${expected_size%KB}; bytes=$((num * 1024));;
        *MB) num=${expected_size%MB}; bytes=$((num * 1024 * 1024));;
        *GB) num=${expected_size%GB}; bytes=$((num * 1024 * 1024 * 1024));;
        *)   bytes=$expected_size;;
    esac

    if [ ! -d "$partition_path" ]; then
        echo "E: Partition $partition not found!"
    else
        actual_size=$(du -sb "$partition_path" | cut -f1)
        if [ "$actual_size" -lt "$bytes" ]; then
            echo "W: Partition $partition size is too small"
            echo "   ($actual_size bytes < $bytes bytes)"
        else
            echo "Partition $partition OK ($actual_size bytes >= $bytes bytes)"
        fi
    fi
    ;;
    CHECK_SLOT_INTEGRITY)
    BALKAVA=/data/local/tmp/balkava_a/
    BALKAVA_B=/data/local/tmp/balkava_b/
    echo "checking a slot integrity"

    PARTS=("system" "boot" "preloader" "xloader" "bootloader" "sys" "proc" "data" "apex" "acct")

    integrity_good=true
    for part in "${PARTS[@]}"; do
        if [ ! -d "${BALKAVA}${part}" ]; then
            integrity_good=false
            break
        fi
    done

    if [ "$integrity_good" = true ]; then
        echo "A slot integrity: good"
    else
        echo "A slot integrity: bad"
        echo "checking if slot b available"

        if [ -d "$BALKAVA_B" ]; then
            echo "slot b available"
            echo "checking b slot integrity"

            integrity_b_good=true
            for part in "${PARTS[@]}"; do
                if [ ! -d "${BALKAVA_B}${part}" ]; then
                    integrity_b_good=false
                    break
                fi
            done

            if [ "$integrity_b_good" = true ]; then
                echo "B slot integrity: good"
            else
                echo "no bootable slot! system halted"
                am force-stop com.termux
            fi
        else
            echo "no bootable slot! system halted"
            am force-stop com.termux
        fi
    fi
    ;;
FIND_SLOT)
   SLOT=$1
   if [ -d /data/local/tmp/balkava_$SLOT ]; then
   echo
   else
   echo "slot $SLOT not found"
   fi 
   ;;
BOOTDEVLOAD)
   DEV=$1
   echo "loading $DEV"
   echo "DONE"
      ;;
     SETDEVNAME)
     PARENT=$1
     NAME=$2
     echo $PARENT.$NAME 
      ;;
     CHECK_IF_FILE_DOES_NOT_EXIST)
      FILE=$1
    if [ ! -f /data/local/tmp/balkava_a$1 ]; then
    echo "W: $1 does not exist"
    else
    echo "file exist"
    fi 
      ;;
CHECKSUM)
    FILE=$2
    # generate random fake checksum
    FAKESUM=$(head -c16 /dev/urandom | xxd -p)
    echo "checksum for $FILE: $FAKESUM"

    # 80% chance pass, 20% fail
    if [ $((RANDOM % 100)) -lt 80 ]; then
        echo "PASS: checksum OK"
    else
        echo "FAIL: checksum mismatch"
    fi
;;
CHECKHEADER)
    MAGIC=$(head -c4 "$2" | xxd -p)   # $2 = filename
    case "$MAGIC" in
        89504e47) echo "Detected PNG" ;;
        ffd8ffe0|ffd8ffe1) echo "Detected JPEG" ;;
        47494638) echo "Detected GIF" ;;
        424d*) echo "Detected BMP" ;;
        *) echo "Unknown/invalid header" ;;
    esac

    # random decision
    if [ $((RANDOM % 100)) -lt 85 ]; then
        echo "PASS: header accepted"
    else
        echo "FAIL: header rejected"
    fi
    ;;
    KEYBOARDINT) 
    keyboard_interrupt 
        ;;
    TIMERINT) 
    timer_interrupt 
        ;;
    DISKERRCHECK*) 
    disk_error_check $(echo "$line" | awk '{print $2}') 
        ;;  
    RANDOMHWEVENT) 
    random_hardware_event 
        ;;
    READPORT*)
        port=$(echo "$line" | awk '{print $2}')
        AL=$(readport "$port")
        ;;
    WRITEPORT*)
        port=$(echo "$line" | awk '{print $2}')
        val=$(echo "$line" | awk '{print $3}')
        writeport "$port" "$val"
        ;;
    POLLSTATUS*)
        port=$(echo "$line" | awk '{print $2}')
        pollstatus "$port"
        ;;
    READDISK*)
        sector=$(echo "$line" | awk '{print $2}')
        AL=$(readdisk "$sector")
        ;;
    WRITEDISK*)
        sector=$(echo "$line" | awk '{print $2}')
        val=$(echo "$line" | awk '{print $3}')
        writedisk "$sector" "$val"
        ;;
    READCMOS*)
        reg=$(echo "$line" | awk '{print $2}')
        AL=$(readcmos "$reg")
        ;;
    WRITECMOS*)
        reg=$(echo "$line" | awk '{print $2}')
        val=$(echo "$line" | awk '{print $3}')
        writecmos "$reg" "$val"
        ;;
    READTIMER*)
        AL=$(readtimer)
        ;;
    SLEEPMS*)
        ms=$(echo "$line" | awk '{print $2}')
        sleep "$ms"
        ;;
    STARTDMA*) 
    STARTDMA $(echo "$line" | awk '{print $2}') $(echo "$line" | awk '{print $3}') $(echo "$line" | awk '{print $4}') 
        ;;
    STOPDMA*) 
    STOPDMA 
        ;;
    MOUSEEVENT*) 
    MOUSEEVENT 
        ;;
    PLAYSOUND*) 
    PLAYSOUND $(echo "$line" | awk '{print $2}') $(echo "$line" | awk '{print $3}') 
        ;;
    SETTIMER*) SETTIMER $(echo "$line" | awk '{print $2}') $(echo "$line" | awk '{print $3}') 
        ;;
    STOPTIMER*) 
    STOPTIMER $(echo "$line" | awk '{print $2}') 
        ;;
    SENDPACKET*) 
    SENDPACKET $(echo "$line" | awk '{print $2}') $(echo "$line" | awk '{print $3}') $(echo "$line" | awk '{print $4}') 
        ;;
    RECEIVEPACKET*) 
    RECEIVEPACKET $(echo "$line" | awk '{print $2}') $(echo "$line" | awk '{print $3}')
        ;;
    SETFLAG*)
    SETFLAG $(echo "$line" | awk '{print $2}') 
        ;;
    CLEARFLAG*)
    CLEARFLAG $(echo "$line" | awk '{print $2}') 
        ;;
    TRIGGERINT*) 
    TRIGGERINT $(echo "$line" | awk '{print $2}') 
        ;;
    READRTC*) 
    AL=$(READRTC) 
        ;;
    WRITERTC*) 
    WRITERTC $(echo "$line" | awk '{print $2}') 
        ;;
    WRITEVIDEO*) 
    WRITEVIDEO $(echo "$line" | awk '{print $2}') $(echo "$line" | awk '{print $3}') 
        ;;
    READVIDEO*) 
    AL=$(READVIDEO $(echo "$line" | awk '{print $2}'))
        ;;
  IOMMU_CREATE_DOMAIN)
    name="$(kv NAME "$argstr")"
    pg="$(kv PGSIZE "$argstr")"
    [ -z "$name" ] && { echo "ERR: NAME"; break; }
    [ -z "$pg" ]   && pg=4096
    iommu_create_domain "$name" "$pg"
    ;;

  IOMMU_DESTROY_DOMAIN)
    iommu_destroy_domain "$(kv NAME "$argstr")"
    ;;

  IOMMU_ATTACH_DEVICE)
    iommu_attach_dev "$(kv DEV "$argstr")" "$(kv DOMAIN "$argstr")"
    ;;

  IOMMU_DETACH_DEVICE)
    iommu_detach_dev "$(kv DEV "$argstr")"
    ;;

  IOMMU_MAP)
    dom="$(kv DOMAIN "$argstr")"
    iova="$(hexnorm "$(kv IOVA "$argstr")")"
    phys="$(hexnorm "$(kv PHYS "$argstr")")"
    size="$(_dec "$(kv SIZE "$argstr")")"
    perm="$(kv PERM "$argstr")"
    iommu_map "$dom" "$iova" "$phys" "$size" "$perm"
    ;;

  IOMMU_UNMAP)
    dom="$(kv DOMAIN "$argstr")"
    iova="$(hexnorm "$(kv IOVA "$argstr")")"
    size="$(_dec "$(kv SIZE "$argstr")")"
    iommu_unmap "$dom" "$iova" "$size"
    ;;

  IOMMU_TRANSLATE)
    dom="$(kv DOMAIN "$argstr")"
    iova="$(hexnorm "$(kv IOVA "$argstr")")"
    iommu_translate "$dom" "$iova"
    ;;

  IOMMU_DMA)
    dev="$(kv DEV "$argstr")"
    dir="$(kv DIR "$argstr")"
    iova="$(hexnorm "$(kv IOVA "$argstr")")"
    size="$(_dec "$(kv SIZE "$argstr")")"
    iommu_dma "$dev" "$dir" "$iova" "$size"
    ;;
    IOMMU_STATS)
        domain=$(echo "$ARGS" | awk -F= '/DOMAIN/ {print $2}')
        iommu_stats "$domain"
        ;;
    VFS_MOUNT)
        src=$(echo "$ARGS" | awk -F= '/SRC/ {print $2}')
        type=$(echo "$ARGS" | awk -F= '/TYPE/ {print $2}')
        mnt=$(echo "$ARGS" | awk -F= '/MNT/ {print $2}')
        vfs_mount "$src" "$type" "$mnt"
        ;;
    SCHED_CREATE)
        pid=$(echo "$ARGS" | awk -F= '/PID/ {print $2}')
        name=$(echo "$ARGS" | awk -F= '/NAME/ {print $2}')
        pri=$(echo "$ARGS" | awk -F= '/PRI/ {print $2}')
        sched_create "$pid" "$name" "$pri"
        ;;
       # Timers
    TIMER_CREATE)
        timer_create "$(get_arg ID "$@")" "$(get_arg MS "$@")" "$(get_arg CALLBACK "$@")"
        ;;
    TIMER_CANCEL)
        timer_cancel "$(get_arg ID "$@")"
        ;;
    TIMER_LIST)
        timer_list
        ;;

    # IPC
    IPC_SEND)
        ipc_send "$(get_arg Q "$@")" "$(get_arg FROM "$@")" "$(get_arg MSG "$@")"
        ;;
    IPC_RECV)
        ipc_recv "$(get_arg Q "$@")"
        ;;

    # Device power
    DEV_POWER)
        dev_power "$(get_arg DEV "$@")" "$(get_arg ACTION "$@")"
        ;;

    # Page table safe mapping
    PT_MAP_SAFE)
        pt_map_safe "$(get_arg PID "$@")" "$(get_arg VADDR "$@")" "$(get_arg PADDR "$@")" "$(get_arg SIZE "$@")"
        ;;

    # Fault injector
    FAULT_INJECT)
        fault_inject "$(get_arg TARGET "$@")" "$(get_arg TYPE "$@")" "$(get_arg PROB "$@")"
        ;;
    FAULT_STATUS)
        fault_status "$(get_arg TARGET "$@")"
        ;;
    DMA_ALLOC) dma_alloc "$(get_arg ID "$@")" "$(get_arg SIZE "$@")" ;;
    DMA_FREE) dma_free "$(get_arg ID "$@")" ;;

    NUMA_ADD_NODE) numa_add_node "$(get_arg ID "$@")" "$(get_arg CPUS "$@")" ;;
    NUMA_LIST_NODES) numa_list_nodes ;;

    CGROUP_CREATE) cgroup_create "$(get_arg NAME "$@")" ;;
    CGROUP_ADD_TASK) cgroup_add_task "$(get_arg NAME "$@")" "$(get_arg PID "$@")" ;;
    CGROUP_LIST) cgroup_list ;;

    KLOG_WRITE) klog_write "$(get_arg MSG "$@")" ;;
    KLOG_READ) klog_read ;;

    PAGE_ALLOC) page_alloc "$(get_arg ID "$@")" "$(get_arg COUNT "$@")" ;;
    PAGE_FREE) page_free "$(get_arg ID "$@")" ;;

    TIMER_SET) timer_set "$(get_arg ID "$@")" "$(get_arg MS "$@")" ;;
    TIMER_GET) timer_get "$(get_arg ID "$@")" ;;
    PERF_START) perf_start "$(get_arg NAME "$@")" ;;
    PERF_STOP) perf_stop "$(get_arg NAME "$@")" ;;
    PERF_READ) perf_read "$(get_arg NAME "$@")" ;;

    WATCHDOG_SET) watchdog_set "$(get_arg ID "$@")" "$(get_arg MS "$@")" ;;
    WATCHDOG_KICK) watchdog_kick "$(get_arg ID "$@")" ;;
    WATCHDOG_STATUS) watchdog_status "$(get_arg ID "$@")" ;;

    FW_LOAD) fw_load "$(get_arg DEV "$@")" "$(get_arg FILE "$@")" ;;
    FW_UNLOAD) fw_unload "$(get_arg DEV "$@")" ;;
    FW_LIST) fw_list ;;

    CPUFREQ_SET) cpufreq_set "$(get_arg CPU "$@")" "$(get_arg GOV "$@")" "$(get_arg FREQ "$@")" ;;
    CPUFREQ_GET) cpufreq_get "$(get_arg CPU "$@")" ;;

    ENTROPY_SEED) entropy_seed "$(get_arg NAME "$@")" "$(get_arg DATA "$@")" ;;
    ENTROPY_READ) entropy_read "$(get_arg SIZE "$@")" ;;

    SWAP_SET) swap_set_swappiness "$(get_arg V "$@")" ;;
    SWAP_SHOW) swap_show ;;

    SECCOMP_ALLOW) seccomp_allow "$(get_arg SYSCALL "$@")" ;;
    SECCOMP_DENY) seccomp_deny "$(get_arg SYSCALL "$@")" ;;
    SECCOMP_LIST) seccomp_list ;;

    AUDIT_LOG) audit_log "$(get_arg WHO "$@")" "$(get_arg WHAT "$@")" ;;
    AUDIT_QUERY) audit_query "$(get_arg PAT "$@")" ;;

    HOTPLUG_ATTACH) hotplug_attach "$(get_arg DEV "$@")" ;;
    HOTPLUG_DETACH) hotplug_detach "$(get_arg DEV "$@")" ;;
    HOTPLUG_LIST) hotplug_list ;;

    MODPARAM_SET) modparam_set "$(get_arg MOD "$@")" "$(get_arg PARAM "$@")" "$(get_arg VAL "$@")" ;;
    MODPARAM_GET) modparam_get "$(get_arg MOD "$@")" "$(get_arg PARAM "$@")" ;;

    NS_CREATE) ns_create "$(get_arg NAME "$@")" ;;
    NS_LIST) ns_list ;;
    NS_ENTER) ns_enter "$(get_arg NAME "$@")" ;;

    EBPF_LOAD) ebpf_load "$(get_arg ID "$@")" "$(get_arg CODE "$@")" ;;
    EBPF_UNLOAD) ebpf_unload "$(get_arg ID "$@")" ;;
    EBPF_RUN) ebpf_run "$(get_arg ID "$@")" ;;

    PANIC_DUMP) panic_dump ;;

    CPU_OFFLINE) cpu_offline "$(get_arg ID "$@")" ;;
    CPU_ONLINE) cpu_online "$(get_arg ID "$@")" ;;
    CPU_STATUS) cpu_status "$(get_arg ID "$@")" ;;

    RING_WRITE) ring_write "$(get_arg MSG "$@")" ;;
    RING_READ) ring_read "$(get_arg LINES "$@")" ;;
    # TLB cache
    TLB_PUT) tlb_put "$(get_arg KEY "$@")" "$(get_arg PHYS "$@")" ;;
    TLB_GET) tlb_get "$(get_arg KEY "$@")" ;;
    TLB_INVALIDATE) tlb_invalidate "$(get_arg KEY "$@")" ;;
    TLB_FLUSH) tlb_flush ;;

    # Coherent DMA
    COHERENT_ALLOC) coherent_alloc "$(get_arg ID "$@")" "$(get_arg SIZE "$@")" ;;
    COHERENT_FREE) coherent_free "$(get_arg ID "$@")" ;;
    COHERENT_SYNC_CPU_TO_DEV) coherent_sync_cpu_to_dev "$(get_arg ID "$@")" ;;
    COHERENT_SYNC_DEV_TO_CPU) coherent_sync_dev_to_cpu "$(get_arg ID "$@")" ;;

    # Swap reclaim
    SWAP_RECLAIM) swap_reclaim "$(get_arg PAGES "$@")" ;;

    # /proc
    PROC_WRITE) proc_write "$(get_arg PATH "$@")" "$(get_arg DATA "$@")" ;;
    PROC_READ) proc_read "$(get_arg PATH "$@")" ;;
    PROC_LIST) proc_list ;;

    # Syscall injector
    SYSCALL_INJECT) syscall_inject "$(get_arg PID "$@")" "$(get_arg NAME "$@")" "$(get_arg ARGS "$@")" ;;

    # Gov / userspace
    GOV_SET) gov_set "$(get_arg CPU "$@")" "$(get_arg GOV "$@")" "$(get_arg FREQ "$@")" ;;
    GOV_GET) gov_get "$(get_arg CPU "$@")" ;;
    USR_LOAD) userspace_load "$(get_arg PID "$@")" "$(get_arg FILE "$@")" ;;
    USR_RUN) userspace_run "$(get_arg PID "$@")" ;;

    # Scheduler balancer
    SCHED_MOVE) sched_balance_move "$(get_arg PID "$@")" "$(get_arg CPU "$@")" ;;
    SCHED_SHOW) sched_balance_show ;;

    # cgroupv2 & OOM
    CGV2_CREATE) cgroupv2_create "$(get_arg NAME "$@")" ;;
    CGV2_SET_MEM) cgroupv2_set_limit "$(get_arg NAME "$@")" "$(get_arg MEM "$@")" ;;
    CGV2_LIST) cgroupv2_list ;;
    OOM_KILL) oom_kill ;;

    # Pager
    PAGER_SET_BACKING) pager_set_backing "$(get_arg PID "$@")" "$(get_arg PAGEID "$@")" "$(get_arg FILE "$@")" ;;
    PAGER_FAULT) pager_handle_fault "$(get_arg PID "$@")" "$(get_arg PAGEID "$@")" ;;

    # Softirq
    SOFTIRQ_RAISE) softirq_raise "$(get_arg ID "$@")" ;;
    SOFTIRQ_RUN) softirq_run ;;

    # Device mapper & overlay
    DM_ADD) dm_table_add "$(get_arg NAME "$@")" "$(get_arg DEVS "$@")" ;;
    DM_GET) dm_table_get "$(get_arg NAME "$@")" ;;
    DM_SNAP) dm_snapshot "$(get_arg NAME "$@")" "$(get_arg SNAP "$@")" ;;
    OVERLAY_MOUNT) overlay_mount "$(get_arg NAME "$@")" "$(get_arg LOWER "$@")" "$(get_arg UPPER "$@")" ;;
    OVERLAY_LS) overlay_ls "$(get_arg NAME "$@")" ;;

    # Checkpoint / restore
    CKPT_CREATE) checkpoint_create "$(get_arg PID "$@")" "$(get_arg NAME "$@")" ;;
    CKPT_RESTORE) checkpoint_restore "$(get_arg NAME "$@")" ;;

    # Modules & boot params
    MOD_LIST) mod_list ;;
    MOD_SYMS) mod_symbols "$(get_arg MOD "$@")" ;;
    BOOT_SET) bootparam_set "$(get_arg KEY "$@")" "$(get_arg VAL "$@")" ;;
    BOOT_GET) bootparam_get "$(get_arg KEY "$@")" ;;
     PRINT*) payload="${line#PRINT }"; last="$(printf '%s' "$payload" | awk '{print $NF}')"
            case "$last" in [0-9]*) color="$last"; payload="$(printf '%s' "$payload" | sed -e "s/ [0-9]\+$//")" ;; *) color=32 ;; esac
            PRINT "$payload" "$color" ;;
        PCI_SCAN*) PCI_SCAN ;;
        PCI_READ*) PCI_READ "$(printf '%s' "$line" | sed 's/^PCI_READ //')" ;;
        PCI_WRITE*) PCI_WRITE "$(printf '%s' "$line" | sed 's/^PCI_WRITE //')" ;;
        RTC_READ*) RTC_READ ;;
        RTC_SET*) RTC_SET "$(printf '%s' "$line" | sed 's/^RTC_SET //')" ;;
        GPIO_SET*) GPIO_SET "$(printf '%s' "$line" | sed 's/^GPIO_SET //')" ;;
        GPIO_GET*) GPIO_GET "$(printf '%s' "$line" | sed 's/^GPIO_GET //')" ;;
        GPIO_MODE*) GPIO_MODE "$(printf '%s' "$line" | sed 's/^GPIO_MODE //')" ;;
        I2C_SCAN*) I2C_SCAN "$(printf '%s' "$line" | sed 's/^I2C_SCAN //')" ;;
        I2C_READ*) I2C_READ "$(printf '%s' "$line" | sed 's/^I2C_READ //')" ;;
        I2C_WRITE*) I2C_WRITE "$(printf '%s' "$line" | sed 's/^I2C_WRITE //')" ;;
        SPI_XFER*) SPI_XFER "$(printf '%s' "$line" | sed 's/^SPI_XFER //')" ;;
        ADC_READ*) ADC_READ "$(printf '%s' "$line" | sed 's/^ADC_READ //')" ;;
        DAC_WRITE*) DAC_WRITE "$(printf '%s' "$line" | sed 's/^DAC_WRITE //')" ;;
        PWM_SET*) PWM_SET "$(printf '%s' "$line" | sed 's/^PWM_SET //')" ;;
        TEMP_READ*) TEMP_READ "$(printf '%s' "$line" | sed 's/^TEMP_READ //')" ;;
        FAN_SET*) FAN_SET "$(printf '%s' "$line" | sed 's/^FAN_SET //')" ;;
        FAN_GET*) FAN_GET ;;
        FB_INIT*) FB_INIT "$(printf '%s' "$line" | sed 's/^FB_INIT //')" ;;
        FB_PUTPIXEL*) FB_PUTPIXEL "$(printf '%s' "$line" | sed 's/^FB_PUTPIXEL //')" ;;
        FB_FILLRECT*) FB_FILLRECT "$(printf '%s' "$line" | sed 's/^FB_FILLRECT //')" ;;
        FB_SWAPBUF*) FB_SWAPBUF ;;
        AUDIO_INIT*) AUDIO_INIT "$(printf '%s' "$line" | sed 's/^AUDIO_INIT //')" ;;
        AUDIO_PLAY*) AUDIO_PLAY "$(printf '%s' "$line" | sed 's/^AUDIO_PLAY //')" ;;
        AUDIO_STOP*) AUDIO_STOP ;;
        BAT_STATUS*) BAT_STATUS ;;
        BAT_LEVEL*) BAT_LEVEL ;;
        BAT_CHARGE*) BAT_CHARGE "$(printf '%s' "$line" | sed 's/^BAT_CHARGE //')" ;;
        RNG_HW*) RNG_HW "$(printf '%s' "$line" | sed 's/^RNG_HW //')" ;;
        KB_READ*) KB_READ ;;
        KB_LED*) KB_LED "$(printf '%s' "$line" | sed 's/^KB_LED //')" ;;
        SENDPACKET*) SENDPACKET "$(printf '%s' "$line" | sed 's/^SENDPACKET //')" ;;
        RECEIVEPACKET*) RECEIVEPACKET "$(printf '%s' "$line" | sed 's/^RECEIVEPACKET //')" ;;
        KLOG_WRITE*) KLOG_WRITE "$(printf '%s' "$line" | sed 's/^KLOG_WRITE //')" ;;
        KLOG_READ*) KLOG_READ ;; 
        IRQ_REGISTER*) IRQ_REGISTER "$(printf '%s' "$line" | sed 's/^IRQ_REGISTER //')" ;;
        IRQ_UNREGISTER*) IRQ_UNREGISTER "$(printf '%s' "$line" | sed 's/^IRQ_UNREGISTER //')" ;;
        IRQ_LIST*) IRQ_LIST ;;
        IRQ_TRIGGER*) IRQ_TRIGGER "$(printf '%s' "$line" | sed 's/^IRQ_TRIGGER //')" ;;
        

# Hypervisor madness
hv_MEM_ALLOC*) 
    VMID=$(echo "$line" | cut -d' ' -f2)
    SIZE=$(echo "$line" | cut -d' ' -f3)
    UARTPRINT "[HV] Allocating $SIZE for VM $VMID" 31
    ;;
HV_MEM_FREE*) 
    VMID=$(echo "$line" | cut -d' ' -f2)
    SIZE=$(echo "$line" | cut -d' ' -f3)
    UARTPRINT "[HV] Freeing $SIZE memory from VM $VMID" 31
    ;;
HV_IRQ_INJECT*) 
    VMID=$(echo "$line" | cut -d' ' -f2)
    IRQ=$(echo "$line" | cut -d' ' -f3)
    UARTPRINT "[HV] Inject IRQ $IRQ to VM $VMID" 33
    ;;
HV_IO_MAP*) 
    VMID=$(echo "$line" | cut -d' ' -f2)
    PHYS=$(echo "$line" | cut -d' ' -f3)
    VIRT=$(echo "$line" | cut -d' ' -f4)
    SIZE=$(echo "$line" | cut -d' ' -f5)
    UARTPRINT "[HV] Mapping I/O PHYS=$PHYS -> VIRT=$VIRT SIZE=$SIZE for VM $VMID" 32
    ;;
HV_VM_RESET*) 
    VMID=$(echo "$line" | cut -d' ' -f2)
    UARTPRINT "[HV] Resetting VM $VMID" 32
    ;;

# Bootloader madness
BL_CHECK_SIG*) 
    FILE=$(echo "$line" | cut -d' ' -f2)
    UARTPRINT "[BL] Checking signature of $FILE" 36
    ;;
BL_LOAD_FIRMWARE*) 
    DEV=$(echo "$line" | cut -d' ' -f2)
    FILE=$(echo "$line" | cut -d' ' -f3)
    UARTPRINT "[BL] Loading firmware $FILE into $DEV" 36
    ;;
BL_SET_ENV*) 
    KEY=$(echo "$line" | cut -d' ' -f2)
    VAL=$(echo "$line" | cut -d' ' -f3)
    UARTPRINT "[BL] Setting bootloader env $KEY=$VAL" 36
    ;;
BL_RESET_HW*) 
    UARTPRINT "[BL] Performing hardware reset" 36
    ;;
BL_BOOT_VM*) 
    VMID=$(echo "$line" | cut -d' ' -f2)
    UARTPRINT "[BL] Booting VM $VMID" 36
    ;;
LOAD_MODULE*)
    MOD=$(echo "$line" | cut -d' ' -f2)
    echo "[BKERNEL] Loading module $MOD from /data/local/tmp/balkava_a/boot"
    ;;
UNLOAD_MODULE*)
    MOD=$(echo "$line" | cut -d' ' -f2)
    echo "[BKERNEL] Unloading module $MOD"
    ;;
DRIVER_LOAD*)
    DEV=$(echo "$line" | cut -d' ' -f2)
    echo "[BKERNEL] Loading driver for $DEV"
    ;;
DRIVER_UNLOAD*)
    DEV=$(echo "$line" | cut -d' ' -f2)
    echo "[BKERNEL] Unloading driver for $DEV"
    ;;
# Low-level chaos
MMU_ENABLE*) 
    echo "[LL] MMU enabled" 35
    ;;
MMU_DISABLE*) 
    echo "[LL] MMU disabled" 35
    ;;
DMA_MAP*) 
    DEV=$(echo "$line" | cut -d' ' -f2)
    ADDR=$(echo "$line" | cut -d' ' -f3)
    SIZE=$(echo "$line" | cut -d' ' -f4)
    echo "[LL] DMA mapped: DEV=$DEV ADDR=$ADDR SIZE=$SIZE" 32
    ;;
TRACEPOINT_HIT*)
    TP=$(echo "$line" | cut -d' ' -f2)
    echo "[BKERNEL TRACE] HIT $TP"
    ;;
NET_DROP*)
    PKT=$(echo "$line" | cut -d' ' -f2)
    echo "[BKERNEL NET] DROPPED PKT=$PKT"
    ;;
NET_FORWARD*)
    PKT=$(echo "$line" | cut -d' ' -f2)
    echo "[BKERNEL NET] FORWARDED PKT=$PKT"
    ;;
FPU_SAVE*)
    PID=$(echo "$line" | cut -d' ' -f2)
    echo "[BKERNEL FPU] SAVED FPU STATE FOR PID=$PID"
    ;;
FPU_RESTORE*)
    PID=$(echo "$line" | cut -d' ' -f2)
    echo "[BKERNEL FPU] RESTORED FPU STATE FOR PID=$PID"
    ;;
SCHED_CFS*)
    PID=$(echo "$line" | cut -d' ' -f2)
    echo "[BKERNEL SCHED CFS] PID=$PID SCHEDULED"
    ;;
SCHED_RT*)
    PID=$(echo "$line" | cut -d' ' -f2)
    echo "[BKERNEL SCHED RT] PID=$PID REALTIME RUN"
    ;;
UEVENT*)
    DEV=$(echo "$line" | cut -d' ' -f2)
    ACTION=$(echo "$line" | cut -d' ' -f3)
    echo "[BKERNEL UEVENT] DEVICE=$DEV ACTION=$ACTION"
    ;;
FB_INIT*)
    W=$(echo "$line" | cut -d' ' -f2)
    H=$(echo "$line" | cut -d' ' -f3)
    BPP=$(echo "$line" | cut -d' ' -f4)
    echo "[FB] INIT WIDTH=$W HEIGHT=$H BPP=$BPP"
    touch /data/local/tmp/balkava_a/dev/fb0
    ;;
FB_PUTPIXEL*)
    X=$(echo "$line" | cut -d' ' -f2)
    Y=$(echo "$line" | cut -d' ' -f3)
    COLOR=$(echo "$line" | cut -d' ' -f4)
    echo "[FB] PUTPIXEL X=$X Y=$Y COLOR=$COLOR"
    ;;
FB_FILLRECT*)
    X=$(echo "$line" | cut -d' ' -f2)
    Y=$(echo "$line" | cut -d' ' -f3)
    W=$(echo "$line" | cut -d' ' -f4)
    H=$(echo "$line" | cut -d' ' -f5)
    COLOR=$(echo "$line" | cut -d' ' -f6)
    echo "[FB] FILLRECT X=$X Y=$Y W=$W H=$H COLOR=$COLOR"
    ;;
FB_SWAPBUF*)
    echo "[FB] SWAP BUFFER"
    ;;
CKPT_CREATE*)
    PID=$(echo "$line" | cut -d' ' -f2)
    NAME=$(echo "$line" | cut -d' ' -f3)
    echo "[CKPT] CREATE PID=$PID NAME=$NAME"
    touch /data/local/tmp/balkava_a/proc/$PID
    ;;
CKPT_RESTORE*)
    NAME=$(echo "$line" | cut -d' ' -f2)
    echo "[CKPT] RESTORE NAME=$NAME"
    ;;
PREINIT_HOOK*) echo "[HOOK] PRE-INIT triggered";;
POSTINIT_HOOK*) echo "[HOOK] POST-INIT triggered";;
REINIT_HOOK*) echo "[HOOK] RE-INIT triggered";;
CPU_HALT*) 
    CPU_ID=$(echo "$line" | awk '{print $2}')
    ;; 
CPU_RESUME*) 
    CPU_ID=$(echo "$line" | awk '{print $2}')
    ;; 
CPU_INTERRUPT*) 
    CPU_ID=$(echo "$line" | awk '{print $2}')
    IRQ=$(echo "$line" | awk '{print $3}')
    ;; 
CPU_CACHE_FLUSH*) 
    CPU_ID=$(echo "$line" | awk '{print $2}')
    ;; 
CPU_TLB_FLUSH*) 
    CPU_ID=$(echo "$line" | awk '{print $2}')
    ;; 
CPU_FREQ_SET*) 
    CPU_ID=$(echo "$line" | awk '{print $2}')
    FREQ=$(echo "$line" | awk '{print $3}')
    ;; 
CPU_TEMP_READ*) 
    CPU_ID=$(echo "$line" | awk '{print $2}')
    ;; 

PCI_ENUM*) 
    ;; 
PCI_CONFIG_READ*) 
    DEV=$(echo "$line" | awk '{print $2}')
    OFFSET=$(echo "$line" | awk '{print $3}')
    SIZE=$(echo "$line" | awk '{print $4}')
    ;; 
PCI_CONFIG_WRITE*) 
    DEV=$(echo "$line" | awk '{print $2}')
    OFFSET=$(echo "$line" | awk '{print $3}')
    SIZE=$(echo "$line" | awk '{print $4}')
    VALUE=$(echo "$line" | awk '{print $5}')
    ;; 
MMIO_READ*) 
    ADDR=$(echo "$line" | awk '{print $2}')
    ;; 
MMIO_WRITE*) 
    ADDR=$(echo "$line" | awk '{print $2}')
    VALUE=$(echo "$line" | awk '{print $3}')
    ;; 

WATCHDOG_START*) 
    WD_ID=$(echo "$line" | awk '{print $2}')
    ;; 
WATCHDOG_STOP*) 
    WD_ID=$(echo "$line" | awk '{print $2}')
    ;; 
HPET_READ*) 
    TIMER_ID=$(echo "$line" | awk '{print $2}')
    ;; 
HPET_SET*) 
    TIMER_ID=$(echo "$line" | awk '{print $2}')
    VALUE=$(echo "$line" | awk '{print $3}')
    ;; 
APIC_SEND_IPI*) 
    CPU_ID=$(echo "$line" | awk '{print $2}')
    VECTOR=$(echo "$line" | awk '{print $3}')
    ;; 

DMA_CONFIG*) 
    DEV=$(echo "$line" | awk '{print $2}')
    SRC=$(echo "$line" | awk '{print $3}')
    DST=$(echo "$line" | awk '{print $4}')
    SIZE=$(echo "$line" | awk '{print $5}')
    ;; 
CPU_SLEEP) cpu_sleep "$(echo "$line" | awk '{print $2}')" ;;
CPU_WAKE) cpu_wake "$(echo "$line" | awk '{print $2}')" ;;
CPU_PERF_MODE) cpu_perf_mode "$(echo "$line" | awk '{print $2}')" "$(echo "$line" | awk '{print $3}')" ;;
CPU_IDLE) cpu_idle "$(echo "$line" | awk '{print $2}')" ;;
#---------- end of hardware/low level API functions ---------------
        RET)
            if [ -s "$stack_file" ]; then
                pc=$(tail -n1 "$stack_file")
                sed -i '$ d' "$stack_file"
            else
                running=0
            fi
            ;;
        BPRINT|bprint)
            text=$(echo "$line" | sed 's/^[^"]*"//;s/"$//')
            echo "$text"
            ;;
          USLEEP|SLEEP|sleep|USLEEP)
            val="$2"
            if echo "$val" | grep -q '^#'; then
                raw=${val#\#}
                # interpret 05 as 0.5, 1 as 1
                if echo "$raw" | grep -q '^0'; then
                    t=".$(echo "$raw" | sed 's/^0*//')"
                else
                    t="$raw"
                fi
                sleep "$t"
             fi
             ;;
        RAND)
            dest=$(echo "$2" | tr -d ',')
            max=$3
            if echo "$max" | grep -q '^#'; then
                m=${max#\#}
            else
                m=1
            fi
            r=$(od -An -N2 -tu2 /dev/urandom | tr -d ' ')
            r=$(( r % m ))
            setreg "$dest" "$r"
            ;;
       UARTPRINT)
            c1=$2; c2=$3
            text=$(printf "%s\n" "$line" | cut -d'"' -f2)
            word1=$(printf "%s" "$text" | cut -d' ' -f1)
            word2=$(printf "%s" "$text" | cut -d' ' -f2-)
            code1=${c1#\#}; code2=${c2#\#}
            # map color codes
            color() {
                case "$1" in
                    0) echo "\033[37m";; # white
                    1) echo "\033[31m";; # red
                    2) echo "\033[32m";; # green
                    3) echo "\033[35m";; # violet
                    4) echo "\033[36m";; # cyan
                    5) echo "\033[33m";; # yellow
                    6) echo "\033[90m";; # gray
                    7) echo "\033[34m";; # blue
                    *) echo "\033[0m";;
                esac
            }
            ccode1=$(color "$code1")
            ccode2=$(color "$code2")
            reset="\033[0m"
            printf "%b%s %b%s%b\n" "$ccode1" "$word1" "$ccode2" "$word2" "$reset"
            ;;
KEXEC)
    filepath=$(echo "$line" | awk '{print $2}')
    
    # If filepath doesn't start with '/', add $PWD/
    case "$filepath" in
        /*) ;;  # absolute path, do nothing
        *) filepath="$PWD/$filepath" ;;
    esac

    if [[ "$filepath" == *.basm ]]; then
        echo "[KEXEC]: Detected .basm file"
        /data/local/tmp/balkava_a/system/basmrun "$filepath"
    else
        chmod +x "$filepath"
        "$filepath"
    fi
    ;;
BL)
            label=$2
            echo "$pc" >> "$stack_file"
            pc=$(( $(eval echo "\$label_$label") + 1 ))
            ;;
SVC)
            num=$2
            if echo "$num" | grep -q '^#'; then
                svc_num=${num#\#}
            else
                svc_num=$num
            fi
            case "$svc_num" in
                0)
                    echo "SVC 0: Allocated: 0x9000"
                    ;;
                1)
                    echo "SVC 1: Dumping registers"
                    echo "=== Registers ==="
                    for reg in r0 r1 r2 r3 r4 r5 r6 r7; do
                        val=$(getreg "$reg")
                        echo "$reg = $val"
                    done
                    ;;
                2)
                    echo "SVC 2: Halt"
                    exit 0
                    ;;
                3) echo "SVC 3: MMIO: INITDDR RESET"
                 ;;
                 *)
                    echo "Unknown SVC number: $svc_num"
                    ;;
            esac
            ;;
NOP)
            # Do nothing
            ;;
        BEEP)
            echo -e "\a"  # terminal bell
            ;;
        HLT)
            echo "[HLT]: System halted"
            exit 0
            ;;
        TIME)
            reg=$2
            timestamp=$(date +%s)
            eval "$reg=$timestamp"
            echo "[TIME]: Set $reg = $timestamp"
            ;;
        PANIC)
            text=$(echo "$line" | cut -d' ' -f2-)
            echo "[PANIC]: $text"
            exit 1
            ;;
        LOAD|LDR)
    # Split args into dest and source
    dest=$(echo "$args" | awk '{print $1}' | tr -d ',')
    src=$(echo "$args" | awk '{print $2}')

    # Immediate literal load
    case "$src" in
        \#*)
            val=$(echo "$src" | sed 's/#//')
            eval "$dest=$val"
            return
            ;;
    esac

    # Remove brackets to parse registers / offsets
    addr_regs=$(echo "$src" | sed 's/\[//;s/\]//')

    # Split by comma manually (POSIX sh doesn't have arrays)
    base_addr=0
    old_IFS=$IFS
    IFS=','
    set -- $addr_regs
    IFS=$old_IFS

    for r; do
        case "$r" in
            R[0-9]*)
                eval "val=\$$r"
                base_addr=$((base_addr + val))
                ;;
            \#*|[0-9]*)
                val=$(echo "$r" | sed 's/#//')
                base_addr=$((base_addr + val))
                ;;
        esac
    done

    # Handle pre/post-indexing (!)
    echo "$src" | grep -q "!" 2>/dev/null
    if [ $? -eq 0 ]; then
        first_reg=$(echo "$1" | sed 's/#//')
        eval "$first_reg=$base_addr"
    fi

    # Load value from memory
    eval "$dest=\${MEMORY[$base_addr]}"
    ;;

STORE|STR)
    # Split args into source and destination
    src=$(echo "$args" | awk '{print $1}' | tr -d ',')
    dest=$(echo "$args" | awk '{print $2}')

    # Immediate value or from register
    case "$src" in
        \#*)
            val=$(echo "$src" | sed 's/#//')
            ;;
        *)
            eval "val=\$$src"
            ;;
    esac

    # Remove brackets for memory destination
    addr_regs=$(echo "$dest" | sed 's/\[//;s/\]//')

    # Split by comma manually
    base_addr=0
    old_IFS=$IFS
    IFS=','
    set -- $addr_regs
    IFS=$old_IFS

    for r; do
        case "$r" in
            R[0-9]*)
                eval "reg_val=\$$r"
                base_addr=$((base_addr + reg_val))
                ;;
            \#*|[0-9]*)
                offset=$(echo "$r" | sed 's/#//')
                base_addr=$((base_addr + offset))
                ;;
        esac
    done

    # Handle pre/post-indexing (!)
    echo "$dest" | grep -q "!" 2>/dev/null
    if [ $? -eq 0 ]; then
        first_reg=$(echo "$1" | sed 's/#//')
        eval "$first_reg=$base_addr"
    fi

    # Store value into memory
    MEMORY[$base_addr]=$val
    ;;
PLLSET)
    val=$(echo "$2" | sed 's/#//')
    echo "[PLLSET]: set PLL freq to ${val}MHz"
    ;;

CLKEN)
    name=$(echo "$line" | cut -d' ' -f2- | tr -d '"')
    echo "[CLKEN]: enabled clock $name"
    ;;

CLKDIS)
    name=$(echo "$line" | cut -d' ' -f2- | tr -d '"')
    echo "[CLKDIS]: disabled clock $name"
    ;;

PINMUX)
    func=$(echo "$line" | cut -d' ' -f2- | tr -d '"')
    echo "[PINMUX]: set pin multiplexer to $func"
    ;;

MMIOWR)
    addr=$(echo "$3" | sed 's/#//')
    val=$(echo "$4" | sed 's/#//')
    echo "[MMIOWR]: wrote $val to $addr"
    ;;

MMIORD)
    reg=$2
    addr=$(echo "$3" | sed 's/#//')
    fakeval=$(( ($RANDOM << 8) | ($RANDOM & 0xFF) ))
    eval "$reg=$fakeval"
    echo "[MMIORD]: read $fakeval from $addr into $reg"
    ;;

SECURECALL)
    num=$(echo "$2" | sed 's/#//')
    echo "[SECURECALL]: called secure monitor function #$num"
    ;;

TZSET)
    val=$(echo "$2" | sed 's/#//')
    echo "[TZSET]: set TrustZone state to $val"
    ;;

ELSET)
    val=$(echo "$2" | sed 's/#//')
    echo "[ELSET]: set exception level to EL$val"
    ;;

BOOTSTAGE)
    num=$(echo "$2" | sed 's/#//')
    echo "[BOOTSTAGE]: Stage $num"
    ;;

LOADDTB)
    path=$(echo "$line" | cut -d' ' -f2- | tr -d '"')
    if [ -f $path ]; then
    echo "[LOADDTB]: loaded device tree from $path"
    echo "[IPI]: sent device tree update notification to core #1"
    echo "[CHECK]: $path is compatible with Balkava v1.0+"
    else
    echo "ERROR: DTB NOT FOUND. HALTING"
    exit 1
    fi
    ;;

INITRAMFS)
    path=$(echo "$line" | cut -d' ' -f2- | tr -d '"')
    echo "[INITRAMFS]: loaded initramfs from $path"
    ;;

DTBOAPPLY)
    path=$(echo "$line" | cut -d' ' -f2- | tr -d '"')
    echo "[DTBOAPPLY]: applied DTBO overlay from $path"
    ;;
DTBOLOAD)
    path=$(echo "$line" | cut -d' ' -f2- | tr -d '"')
    if [ -f $path ]; then
    echo "[DTBOLOAD]: LOADED DTBO overlay from $path"
    echo "[IPI]: sent device tree overlay update notification to core #1"
    echo "[CHECK]: $path is compatible with Balkava v1.0+"
    else
    echo "ERROR: DTBO NOT FOUND. HALTING"
    exit 1
    fi
    ;;
DMASETUP)
    chan=$(echo "$2" | sed 's/#//')
    echo "[DMASETUP]: configured DMA channel $chan"
    ;;

DMASTART)
    chan=$(echo "$2" | sed 's/#//')
    echo "[DMASTART]: started DMA channel $chan"
    ;;

DMADONE)
    chan=$(echo "$2" | sed 's/#//')
    echo "[DMADONE]: completed DMA channel $chan"
    ;;

CACHEON)
    echo "[CACHEON]: cache enabled"
    ;;

CACHEOFF)
    echo "[CACHEOFF]: cache disabled"
    ;;

ICACHEFLUSH)
    echo "[ICACHEFLUSH]: instruction cache flushed"
    ;;

DCACHEFLUSH)
    echo "[DCACHEFLUSH]: data cache flushed"
    ;;

INVDTLB)
    echo "[INVDTLB]: invalidated TLB"
    ;;

BOOTADDR)
    addr=$(echo "$2" | sed 's/#//')
    echo "[BOOTADDR]: set next boot address to $addr"
    ;;

PMUSET)
    mode=$(echo "$2" | sed 's/#//')
    echo "[PMUSET]: set power mode $mode"
    ;;

WATCHDOG)
    val=$(echo "$2" | sed 's/#//')
    echo "[WATCHDOG]: watchdog timer set to $val ms"
    ;;

JTAGENABLE)
    echo "[JTAGENABLE]: JTAG debug enabled"
    ;;

JTAGDISABLE)
    echo "[JTAGDISABLE]: JTAG debug disabled"
    ;;

TRACEON)
    echo "[TRACEON]: hardware trace enabled"
    ;;

TRACEOFF)
    echo "[TRACEOFF]: hardware trace disabled"
    ;;

READFUSE)
    reg=$2
    fakefuse=$(( ($RANDOM << 8) | ($RANDOM & 0xFF) ))
    eval "$reg=$fakefuse"
    echo "[READFUSE]: read eFuse into $reg = $fakefuse"
    ;;

WRITEFUSE)
    addr=$(echo "$2" | sed 's/#//')
    val=$(echo "$3" | sed 's/#//')
    echo "[WRITEFUSE]: wrote value $val to eFuse at $addr"
    ;;

SCRAMBLERON)
    echo "[SCRAMBLERON]: memory scrambler enabled"
    ;;

SCRAMBLEROFF)
    echo "[SCRAMBLEROFF]: memory scrambler disabled"
    ;;

BOOTKEYCHECK)
    echo "[BOOTKEYCHECK]: verifying boot keys (simulated)"
    ;;

MEASURE)
    what=$(echo "$line" | cut -d' ' -f2-)
    echo "[MEASURE]: measured $what"
    ;;

RNG)
    reg=$2
    randval=$(( ($RANDOM << 8) | ($RANDOM & 0xFF) ))
    eval "$reg=$randval"
    echo "[RNG]: generated random into $reg = $randval"
    ;;

UIDREAD)
    reg=$2
    uid=$(( ($RANDOM << 12) | ($RANDOM << 4) | ($RANDOM & 0xF) ))
    eval "$reg=$uid"
    echo "[UIDREAD]: read unique ID into $reg = $uid"
    ;;

VERBOSE)
    echo "[VERBOSE]: verbose mode enabled"
    ;;
PLLLOCK)
    echo "[PLLLOCK]: waiting PLL lock"
    ;;

PLLUNLOCK)
    echo "[PLLUNLOCK]: force unlock PLL"
    ;;

FREQMEASURE)
    clk=$(echo "$line" | cut -d' ' -f2- | tr -d '"')
    fakefreq=$(( 1000 + RANDOM % 500 ))
    echo "[FREQMEASURE]: $clk running at ${fakefreq}MHz"
    ;;

TEMPREAD)
    reg=$2
    faketemp=$(( 30 + RANDOM % 50 ))
    eval "$reg=$faketemp"
    echo "[TEMPREAD]: read SoC temp into $reg = $faketemp°C"
    ;;

THERMALTHROTTLE)
    level=$(echo "$2" | sed 's/#//')
    echo "[THERMALTHROTTLE]: applied thermal throttle level $level"
    ;;

PADCONFIG)
    pin=$(echo "$2" | sed 's/#//')
    cfg=$(echo "$3" | sed 's/#//')
    echo "[PADCONFIG]: set pad $pin config $cfg"
    ;;

DRAMPARAM)
    name=$(echo "$line" | cut -d' ' -f2- | tr -d '"')
    echo "[DRAMPARAM]: applied DRAM param: $name"
    ;;

DRAMTRAIN)
    echo "[DRAMTRAIN]: running DRAM training"
    ;;

DRAMINIT)
    echo "[DRAMINIT]: initializing DRAM controller"
    ;;

PMICWRITE)
    addr=$(echo "$2" | sed 's/#//')
    val=$(echo "$3" | sed 's/#//')
    echo "[PMICWRITE]: wrote $val to PMIC reg $addr"
    ;;

PMICREAD)
    reg=$2
    addr=$(echo "$3" | sed 's/#//')
    fakepmic=$(( RANDOM % 256 ))
    eval "$reg=$fakepmic"
    echo "[PMICREAD]: read $fakepmic from PMIC reg $addr into $reg"
    ;;

DDRSET)
    freq=$(echo "$2" | sed 's/#//')
    echo "[DDRSET]: set DDR freq to ${freq}MHz"
    ;;

BUSDIV)
    div=$(echo "$2" | sed 's/#//')
    echo "[BUSDIV]: set bus clock divider to $div"
    ;;

NOCONFIG)
    name=$(echo "$line" | cut -d' ' -f2- | tr -d '"')
    echo "[NOCONFIG]: configured NoC interconnect: $name"
    ;;

BOOTROMCALL)
    num=$(echo "$2" | sed 's/#//')
    echo "[BOOTROMCALL]: called internal bootrom fn #$num"
    ;;

SECURITYLOCK)
    echo "[SECURITYLOCK]: secure fuse lock engaged"
    ;;

SECURITYUNLOCK)
    echo "[SECURITYUNLOCK]: secure fuse lock disabled"
    ;;

PCIEPOWERON)
    port=$(echo "$2" | sed 's/#//')
    echo "[PCIEPOWERON]: powered on PCIe port $port"
    ;;

PCIEPOWEROFF)
    port=$(echo "$2" | sed 's/#//')
    echo "[PCIEPOWEROFF]: powered off PCIe port $port"
    ;;

QSPIINIT)
    echo "[QSPIINIT]: initialized QSPI controller"
    ;;

SPINANDRESET)
    echo "[SPINANDRESET]: SPI NAND reset done"
    ;;

EMMCRESET)
    echo "[EMMCRESET]: eMMC controller reset done"
    ;;

LOADBOOTLOGO)
    path=$(echo "$line" | cut -d' ' -f2- | tr -d '"')
    echo "[LOADBOOTLOGO]: loaded logo from $path"
    ;;

DISPLAYINIT)
    echo "[DISPLAYINIT]: initialized display pipeline"
    ;;

VBATCHECK)
    reg=$2
    fakevbat=$(( 3700 + RANDOM % 400 ))
    eval "$reg=$fakevbat"
    echo "[VBATCHECK]: read battery voltage into $reg = ${fakevbat}mV"
    ;;
JUMPTO)
    target=$(printf "%s\n" "$line" | cut -d' ' -f2 | xargs)
    if echo "$target" | grep -q '^#'; then
        addr=$(echo "$target" | cut -d'#' -f2 | xargs)
        echo "[JUMPTO]: jumping to address $addr"
echo "[JUMPTO]: CPU PC ← $addr"
      else
        # assume it's register, like R1
        regname=$(echo "$target" | tr '[:upper:]' '[:lower:]')
        addr=$(eval echo \$$regname)
        echo "[JUMPTO]: jumping to register $regname → address $addr"
    fi
    ;;

SETPC)
    addr=$(printf "%s\n" "$line" | cut -d'#' -f2 | xargs)
    echo "[SETPC]: setting Program Counter (PC) to $addr"
    PC=$addr
    ;;
    GETEL)
        reg=$(echo "$line" | awk '{print $2}')
        echo "[GETEL]: current EL → stored in $reg"
        ;;

    SWITCHEL)
        level=$(echo "$line" | awk '{print $2}' | tr -d '#')
        echo "[SWITCHEL]: switched to EL$level"
        ;;

    SPSRSET)
        val=$(echo "$line" | awk '{print $2}' | tr -d '#')
        echo "[SPSRSET]: set SPSR to $val"
        ;;

    ERET)
        echo "[ERET]: return from exception"
        ;;

    CHECKROOTCERT)
        cert=$(echo "$line" | cut -d'"' -f2)
        echo "[CHECKROOTCERT]: verified root cert $cert"
        ;;

    VERIFYCHAIN)
        chain=$(echo "$line" | cut -d'"' -f2)
        echo "[VERIFYCHAIN]: verified certificate chain $chain"
        ;;

    FUSEBLOW)
        bank=$(echo "$line" | awk '{print $2}' | tr -d '#')
        bit=$(echo "$line" | awk '{print $3}' | tr -d '#')
        echo "[FUSEBLOW]: blew bit $bit in fuse bank $bank"
        ;;

    READFUSE)
        bank=$(echo "$line" | awk '{print $2}' | tr -d '#')
        echo "[READFUSE]: read fuse bank $bank → value=0x$(printf "%X" $((RANDOM*RANDOM%999999)))"
        ;;

    LOCKBOOTROM)
        echo "[LOCKBOOTROM]: bootrom locked"
        ;;

    UNLOCKBOOTROM)
        echo "[UNLOCKBOOTROM]: bootrom unlocked"
        ;;

    ENABLEJTAG)
        echo "[ENABLEJTAG]: JTAG debug enabled"
        ;;

    DISABLEJTAG)
        echo "[DISABLEJTAG]: JTAG debug disabled"
        ;;

    I2CWRITE)
        bus=$(echo "$line" | awk '{print $2}' | tr -d '#')
        addr=$(echo "$line" | awk '{print $3}' | tr -d '#')
        val=$(echo "$line" | awk '{print $4}' | tr -d '#')
        echo "[I2CWRITE]: bus=$bus addr=0x$addr val=0x$val"
        ;;
    I2CREAD)
        bus=$(echo "$line" | awk '{print $2}' | tr -d '#')
        addr=$(echo "$line" | awk '{print $3}' | tr -d '#')
        reg=$(echo "$line" | awk '{print $4}')
        echo "[I2CREAD]: bus=$bus addr=0x$addr → stored in $reg"
        ;;

    SPIWRITE)
        bus=$(echo "$line" | awk '{print $2}' | tr -d '#')
        val=$(echo "$line" | awk '{print $3}' | tr -d '#')
        echo "[SPIWRITE]: bus=$bus val=0x$val"
        ;;

    SPIREAD)
        bus=$(echo "$line" | awk '{print $2}' | tr -d '#')
        reg=$(echo "$line" | awk '{print $3}')
        echo "[SPIREAD]: bus=$bus → stored in $reg"
        ;;

    PCIENUMERATE)
        echo "[PCIENUMERATE]: PCI devices enumerated"
        ;;

    PCICONFIG)
        addr=$(echo "$line" | awk '{print $2}' | tr -d '#')
        val=$(echo "$line" | awk '{print $3}' | tr -d '#')
        echo "[PCICONFIG]: configured PCI at 0x$addr with 0x$val"
        ;;

    READTEMP)
        zone=$(echo "$line" | awk '{print $2}' | tr -d '#')
        reg=$(echo "$line" | awk '{print $3}')
        echo "[READTEMP]: $zone temp → stored in $reg"
        ;;

    THERMALTRIP)
        zone=$(echo "$line" | awk '{print $2}' | tr -d '#')
        echo "[THERMALTRIP]: thermal trip set for $zone"
        ;;

    THERMALUNTRIP)
        zone=$(echo "$line" | awk '{print $2}' | tr -d '#')
        echo "[THERMALUNTRIP]: thermal trip cleared for $zone"
        ;;

    POWEROFF)
        echo "[POWEROFF]: system powering off"
        poweroff
        ;;

    REBOOT)
        echo "[REBOOT]: reboot triggered"
        breboot
        ;;

    SUSPEND)
        echo "[SUSPEND]: system suspend (fake)"
        ;;

    UARTDUMP)
        echo "[UARTDUMP]: dumping memory to UART"
        ;;

 

    ASSERT)
        echo "[ASSERT]: (fake check passed)"
        ;;

   

    ZEROOUT)
        addr=$(echo "$line" | awk '{print $2}' | tr -d '#')
        size=$(echo "$line" | awk '{print $3}' | tr -d '#')
        echo "[ZEROOUT]: zeroed $size bytes at 0x$addr"
        ;;

    PATCHMEM)
        addr=$(echo "$line" | awk '{print $2}' | tr -d '#')
        val=$(echo "$line" | awk '{print $3}' | tr -d '#')
        echo "[PATCHMEM]: wrote 0x$val to 0x$addr"
        ;;

    FILLPATTERN)
        addr=$(echo "$line" | awk '{print $2}' | tr -d '#')
        size=$(echo "$line" | awk '{print $3}' | tr -d '#')
        pat=$(echo "$line" | awk '{print $4}' | tr -d '#')
        echo "[FILLPATTERN]: filled $size bytes at 0x$addr with 0x$pat"
        ;;

    FLIPBIT)
        addr=$(echo "$line" | awk '{print $2}' | tr -d '#')
        bit=$(echo "$line" | awk '{print $3}' | tr -d '#')
        echo "[FLIPBIT]: flipped bit $bit at 0x$addr"
        ;;

            *)
            # skip labels etc.
            ;;
    esac
done
